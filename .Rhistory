pred_file_opp <- switch(as.character(t_game),rps = rps_predict_opp,fwg = fwg_predict_opp, numbers = numbers_predict_opp)
if(t_game == "numbers") nopts <- 5 else nopts <- 3
if(data[t,"round"] == 1) {
# first round is uniform prediction
pred_opp <- NA
lik_hum[t] <- 1/nopts
## KEY CODE FOR LEARNING TRANSFER !! (if no OM transferreset prior to uniform)
if (!(opp_mod_transfer)) {
opp_prior_vec <- rep(1/num_strat, num_strat)
lik_opp[,t] <- opp_prior_vec
}
# Rounds after first
} else {
# get prediction of opponent action from CSV files
for (strategy in opp_strategy_vec) {
k = match(strategy,opp_strategy_vec)
pred_opp <- as.character(filter(pred_file_opp, pred_file_opp$human_previous == as.character(data[t-1,"h_action"]) & pred_file_opp$computer_previous == as.character(data[t-1,"a_action"]))[[strategy]])
# Given opponent action predicted, what would be human action best response for each opp strat
br_hum[[k]] <- best_response(t_game,as.character(pred_opp))
# Multiply prior by likelihood of observation to get posterior. Done here ot take advantage of For loop.
if(as.character(data[t,"a_action"]) == pred_opp) {
lik_opp[k,t] <- (theta + (1-theta)/nopts)*opp_prior_vec[k]
} else {
lik_opp[k,t] <- ((1-theta)/nopts)*opp_prior_vec[k]
}
}
# Get which opponent strategy human current actn maps to (if index = 0 then human current action is br to level-0 comp_strat...)
indices <- which(br_hum %in% as.character(data[t,"h_action"]))
# THEN likelihood of current human action is just prior on opponent vec (haven't updated priors with curr opp act yet)
# if action is not predicted by any level-k OM, assume human chooses randomly with prob eps
if(length(indices) == 0){
lik_hum[t] <- eps/nopts
# if same br action for multiple possible ai opponents, add probabilities
} else {
lik_hum[t] <- sum(opp_prior_vec[indices])*(1-eps) + eps/nopts
}
# Standardising the probabilities and updating prior
lik_opp[,t] <- lik_opp[,t]/sum(lik_opp[,t])
opp_prior_vec <- lik_opp[,t]
}
# for debugging uncomment the line below
#cat(as.character(pred_opp),as.character(data[t,"a_action"]),lik_opp[,t],"\n")
}
if(return_value == "-2loglik") {
ret <- -2*sum(log(lik_hum))
if(is.infinite(ret) || is.nan(ret)) {
return(1e+300)
} else {
return(ret)
}
}
if(return_value == "likelihood_by_trial") return(lik_hum)
}
# data = subset(dat,human_id == "38VxtUSv_h6RR5-tAAA2")
# naive_bayes(c(0.9,0.99),data,c("level0","level1","level2"),"-2loglik",FALSE)
TR_bayes_modelling <- list()
for(id in unique(dat$human_id)) {
TR_bayes_modelling[[id]] <- list()
tdat <- subset(dat,human_id == id)
# TR_bayes_modelling[[id]] <- DEoptim(fn=naive_bayes, lower = c(0,0), upper = c(1,1), data=tdat, opp_strategy_vec = c("level0","level1","level2") ,return_value = "-2loglik", opp_mod_transfer = TRUE, control=list(trace = FALSE, parallelType=1,parVar = c("best_response")))
TR_bayes_modelling[[id]] <- optim(c(0.1,0.1),fn=naive_bayes,gr = NULL, data=tdat,opp_strategy_vec = c("level0","level1","level2"),return_value = "-2loglik", opp_mod_transfer = TRUE,lower = c(0.01,0.01), upper = c(0.99,0.99), method="L-BFGS-B")
}
library(knitr)
knitr::opts_chunk$set(echo = TRUE)
library(knitr)
knitr::opts_chunk$set(echo = TRUE)
dat <- read.csv("data20180719.csv")
#dat <- read.csv("test_data.csv")
# using some functions from the 'tidyverse' (also for me to get use to them ;-)
library(tidyr)
library(dplyr)
library(DEoptim)
#library(optimParallel)
# library(ggpubr)
# transform 'winner' variable in numeric score
dat$score <- recode(dat$winner, human = 1, tie = 0, ai = -1)
# create a new variable 'block' with round 1...25 = block 1 and round 26...50 as block 2
dat$block <- as.numeric(cut(dat$round,2))
# create a new data.frame in a 'wide format'
# widedata <- dat %>%
#   unite(game_block,game,block) %>% # this creates a new variable which combines game and block
#     group_by(human_id,condition,game_block) %>% # let the functions know you want to separate things by ID, condition, and game_block
#       summarize(mean_score = mean(score)) %>% # compute average score (i.e wins - losses)
#         spread(game_block,mean_score) # reformat in the 'wide' format
# # save the data file as a .csv to use in e.g. SPSS
# write.csv(widedata,row.names=FALSE,file="scores_wide.csv")
# read in the various files which
rps_predict_opp <- read.csv("rps_predict_opp.csv")
fwg_predict_opp <- read.csv("fwg_predict_opp.csv")
numbers_predict_opp <- read.csv("numbers_predict_opp.csv")
# recode actions to make them equal to the codes in these files
dat$h_action <- recode(dat$human_action,"rock" = "R", "paper" = "P", "scissors" = "S", "fire" = "F", "water" = "W", "grass" = "G", "one" = "1", "two" = "2", "three" = "3", "four" = "4", "five" = "5")
dat$a_action <- recode(dat$ai_action,"rock" = "R", "paper" = "P", "scissors" = "S", "fire" = "F", "water" = "W", "grass" = "G", "one" = "1", "two" = "2", "three" = "3", "four" = "4", "five" = "5")
# logit tranformation
my_logit <- function(x) {
ret <- log(x/(1-x))
ret[x==0] <- -Inf
ret[x==1] <- Inf
return(ret)
}
# inverse logit transformation
my_logistic <- function(x) {
ret <- 1/(1+exp(-x))
ret[x == -Inf] <- 0.0
ret[x == Inf] <- 1.0
return(ret)
}
# FIXED STRATEGIES (level-k)
# create a function which computes the -2 log Likelihood over the three games for a particular strategy
# modelLL <- function(par,data,strategy, return_value=c("-2logLik","likelihood_by_trial")) {
#   # par = parameter vector (just has one element here)
#   # dat = data subset for one participant
#   # strategy = c("level1","level2","level3","WSLS")
#   # return = -2logLik (default, for use in optimization) or "likelihood_by_trial" (for later plotting, etc)
#   return_value <- match.arg(return_value)
#
#   # count the number of supplied parameters. If 1, it is a _1 model,
#   # if 3, it is a _3 model. For the _3 model we will use unbounded
#   # optimization (transforming parameters from a logit scale back to 0 to 1)
#   n_theta <- length(par)
#   if(n_theta == 3) par <-my_logistic(par)
#   theta <- par[1]
#   # set up a vector to store the likelihood
#   lik <- rep(0.0,nrow(data))
#   for(t in 1:nrow(data)) {
#     t_game <- data[t,"game"]
#     pred_file <- switch(as.character(t_game),rps=rps_predict,fwg = fwg_predict, numbers = numbers_predict)
#     if(n_theta == 3) {
#       theta <- switch(as.character(t_game),rps=par[1],fwg = par[2], numbers = par[3])
#     }
#     if(t_game == "numbers") nopts <- 5 else nopts <- 3
#     if(data[t,"round"] == 1) {
#       # first round is uniform prediction
#       pred <- NA
#       lik[t] <- 1/nopts
#     } else {
#       # get prediction from file
#       pred <- as.character(filter(pred_file,human_previous == as.character(data[t-1,"h_action"]) & computer_previous == as.character(data[t-1,"a_action"]))[strategy][1,])
#       if(as.character(data[t,"h_action"]) == pred) {
#         lik[t] <- theta + (1-theta)/nopts
#       } else {
#         lik[t] <- (1-theta)/nopts
#       }
#     }
#     # for debugging uncomment the line below
#     # cat(as.character(pred),as.character(data[t,"h_action"]),lik[t],"\n")
#   }
#   if(return_value == "-2logLik") {
#     ret <- -2*sum(log(lik))
#     if(ret == Inf) {
#       return(1e+300)
#     } else {
#       return(ret)
#     }
#   }
#   if(return_value == "likelihood_by_trial") return(lik)
# }
#
# all_modelling <- list()
# for(id in unique(dat$human_id)) {
#   all_modelling[[id]] <- list()
#   tdat <- subset(dat,human_id == id)
#   # level 1
#   all_modelling[[id]]$level1_1 <- optimize(modelLL,interval=c(0,1),data=tdat,strategy="level1")
#   all_modelling[[id]]$level1_3 <- optim(my_logit(rep(all_modelling[[id]]$level1_1$minimum,3)),fn=modelLL,data=tdat,strategy="level1")
#   # level 2
#   all_modelling[[id]]$level2_1 <- optimize(modelLL,interval=c(0,1),data=tdat,strategy="level2")
#   all_modelling[[id]]$level2_3 <- optim(my_logit(rep(all_modelling[[id]]$level2_1$minimum,3)),fn=modelLL,data=tdat,strategy="level2")
#   # level 3
#   all_modelling[[id]]$level3_1 <- optimize(modelLL,interval=c(0,1),data=tdat,strategy="level3")
#   all_modelling[[id]]$level3_3 <- optim(my_logit(rep(all_modelling[[id]]$level3_1$minimum,3)),fn=modelLL,data=tdat,strategy="level3")
#   # WSLS
#   all_modelling[[id]]$WSLS_1 <- optimize(modelLL,interval=c(0,1),data=tdat,strategy="WSLS")
#   all_modelling[[id]]$WSLS_3 <- optim(my_logit(rep(all_modelling[[id]]$WSLS_1$minimum,3)),fn=modelLL,data=tdat,strategy="WSLS")
# }
#
# save(all_modelling,file="all_modelling.RData")
# create a table with BIC
# BIC_results <- data.frame()
# for(id in unique(dat$human_id)) {
#     BIC_results <- rbind(BIC_results,
#                          data.frame(
#                            "id" = id,
#                            "condition" = dat[dat$human_id==id,"condition"][1],
#                            "random_BIC" = -2*(100*log(1/3) + 50*log(1/5)),
#                            "level1_1_theta" = all_modelling[[id]]$level1_1$minimum,
#                            "level1_1_BIC" = all_modelling[[id]]$level1_1$objective + 1*log(150),
#                            "level1_3_theta1" = my_logistic(all_modelling[[id]]$level1_3$par[1]),
#                            "level1_3_theta2" = my_logistic(all_modelling[[id]]$level1_3$par[2]),
#                            "level1_3_theta3" = my_logistic(all_modelling[[id]]$level1_3$par[3]),
#                            "level1_3_BIC" = all_modelling[[id]]$level1_3$value + 3*log(150),
#                            "level2_1_theta" = all_modelling[[id]]$level2_1$minimum,
#                            "level2_1_BIC" = all_modelling[[id]]$level2_1$objective + 1*log(150),
#                            "level2_3_theta1" = my_logistic(all_modelling[[id]]$level2_3$par[1]),
#                            "level2_3_theta2" = my_logistic(all_modelling[[id]]$level2_3$par[2]),
#                            "level2_3_theta3" = my_logistic(all_modelling[[id]]$level2_3$par[3]),
#                            "level2_3_BIC" = all_modelling[[id]]$level2_3$value + 3*log(150),
#                            "level3_1_theta" = all_modelling[[id]]$level3_1$minimum,
#                            "level3_1_BIC" = all_modelling[[id]]$level3_1$objective + 1*log(150),
#                            "level3_3_theta1" = my_logistic(all_modelling[[id]]$level3_3$par[1]),
#                            "level3_3_theta2" = my_logistic(all_modelling[[id]]$level3_3$par[2]),
#                            "level3_3_theta3" = my_logistic(all_modelling[[id]]$level3_3$par[3]),
#                            "level3_3_BIC" = all_modelling[[id]]$level3_3$value + 3*log(150),
#                            "WSLS_1_theta" = all_modelling[[id]]$WSLS_1$minimum,
#                            "WSLS_1_BIC" = all_modelling[[id]]$WSLS_1$objective + 1*log(150),
#                            "WSLS_3_theta1" = my_logistic(all_modelling[[id]]$WSLS_3$par[1]),
#                            "WSLS_3_theta2" = my_logistic(all_modelling[[id]]$WSLS_3$par[2]),
#                            "WSLS_3_theta3" = my_logistic(all_modelling[[id]]$WSLS_3$par[3]),
#                            "WSLS_3_BIC" = all_modelling[[id]]$WSLS_3$value + 3*log(150)
#                          ))
# }
# write.csv(BIC_results,file="BIC_result.csv",row.names = FALSE)
# kable(BIC_results)
# create a table with best fitting models by condition
# table(dat$condition[dat$round==1 & dat$game == "rps"],c("random","level1_1","level2_1","level3_1","WSLS_1","level1_3","level2_3","level3_3","WSLS_3")[apply(BIC_results[,c("random_BIC","level1_1_BIC","level2_1_BIC","level3_1_BIC","WSLS_1_BIC","level1_3_BIC","level2_3_BIC","level3_3_BIC","WSLS_3_BIC")],1,which.min)])
#
# ## treat 1 theta and 3 theta versions the same
# # create a table with best fitting models by condition
# table(dat$condition[dat$round==1 & dat$game == "rps"],c("random","level1","level2","level3","WSLS","level1","level2","level3","WSLS")[apply(BIC_results[,c("random_BIC","level1_1_BIC","level2_1_BIC","level3_1_BIC","WSLS_1_BIC","level1_3_BIC","level2_3_BIC","level3_3_BIC","WSLS_3_BIC")],1,which.min)])
#
# long_likelihood_by_trial <- data.frame()
# for(id in unique(dat$human_id)) {
#   tdat <- subset(dat,human_id == id)
#   for(strategy in c("level1","level2","level3","WSLS")) {
#     long_likelihood_by_trial <- rbind(long_likelihood_by_trial,
#                                       data.frame(id = id,
#                                                  condition = dat[dat$human_id==id,"condition"][1],
#                                                  strategy = strategy,
#                                                  round = 1:50,
#                                                  game = rep(c("rps","fwg","numbers"),each=50),
#                                                  likelihood = modelLL(all_modelling[[id]][[paste(strategy,"_3",sep="")]]$par,
#                                                                       data=tdat,
#                                                                       strategy = strategy,
#                                                                       return_value = "likelihood_by_trial")
#                                       )
#                                 )
#   }
# }
# library(ggplot2)
# plot_dat <- long_likelihood_by_trial %>% group_by(condition,game,round,strategy) %>%
#       summarize(probability = mean(likelihood))
# # make sure the different games are ordered in the way they were played
# plot_dat$game <- factor(plot_dat$game,levels=c("rps","fwg","numbers"))
# ggplot(plot_dat,aes(x=round,y=probability,colour=strategy)) + geom_line() + facet_grid(game~condition)
# Function to produce best reponse to ai_action
best_response <- function(game,ai_action){
if (game == "rps"){
if (ai_action == "R") {return("P")}
else if (ai_action == "P") {return("S")}
else if (ai_action == "S") {return("R")}
} else if (game == "fwg"){
if (ai_action == "F") {return("W")}
else if (ai_action == "W") {return("G")}
else if (ai_action == "G") {return("F")}
} else if (game == "numbers") {
if (ai_action == "1") {return("2")}
else if (ai_action == "2") {return("3")}
else if (ai_action == "3") {return("4")}
else if (ai_action == "4") {return("5")}
else if (ai_action == "5") {return("1")}
}
}
naive_bayes <- function(par,data,opp_strategy_vec,return_value,opp_mod_transfer) {
# dat = data subset for one participant
# opp_strategy_vec = vector of possible opponent strtegies, model assumes humans restrict opp strategy space to vector   c("level0","level1","level2")
# return = -2logLik
# or "likelihood_by_trial" vector  (for later plotting, etc)
# opp_mod_transfer is a boolean. True if distribution of opponent strategies is kept across games. False otherwise.
# theta = parameter, probability computer will play its best response to what it thinks human is. Truth = 90%. in [0,1].
# eps: parameter controlling noise in human choice. Probability human will DEVIATE from its best response. In [0,1].
theta <- par[1]
eps <- par[2]
num_strat = length(opp_strategy_vec)
# Load tables predicting oppponent move
rps_predict_opp <- read.csv("rps_predict_opp.csv")
fwg_predict_opp <- read.csv("fwg_predict_opp.csv")
numbers_predict_opp <- read.csv("numbers_predict_opp.csv")
#lik_opp is a vector that holds and update probability distribution of opp strategy given actions.
lik_opp <- matrix(0.0,num_strat, nrow(data))
# Initiate prior vector as uniform
opp_prior_vec <-rep(1/num_strat, num_strat)
lik_hum <- matrix(0.0,nrow(data))
# br_hum is vector that stores best responses of human to actions taken by each level-k ai opponent at the round.
br_hum <- rep(NA,num_strat)
for(t in 1:nrow(data)) {
t_game <- data[t,"game"]
pred_file_opp <- switch(as.character(t_game),rps = rps_predict_opp,fwg = fwg_predict_opp, numbers = numbers_predict_opp)
if(t_game == "numbers") nopts <- 5 else nopts <- 3
if(data[t,"round"] == 1) {
# first round is uniform prediction
pred_opp <- NA
lik_hum[t] <- 1/nopts
## KEY CODE FOR LEARNING TRANSFER !! (if no OM transferreset prior to uniform)
if (!(opp_mod_transfer)) {
opp_prior_vec <- rep(1/num_strat, num_strat)
lik_opp[,t] <- opp_prior_vec
}
# Rounds after first
} else {
# get prediction of opponent action from CSV files
for (strategy in opp_strategy_vec) {
k = match(strategy,opp_strategy_vec)
pred_opp <- as.character(filter(pred_file_opp, pred_file_opp$human_previous == as.character(data[t-1,"h_action"]) & pred_file_opp$computer_previous == as.character(data[t-1,"a_action"]))[[strategy]])
# Given opponent action predicted, what would be human action best response for each opp strat
br_hum[[k]] <- best_response(t_game,as.character(pred_opp))
# Multiply prior by likelihood of observation to get posterior. Done here ot take advantage of For loop.
if(as.character(data[t,"a_action"]) == pred_opp) {
lik_opp[k,t] <- (theta + (1-theta)/nopts)*opp_prior_vec[k]
} else {
lik_opp[k,t] <- ((1-theta)/nopts)*opp_prior_vec[k]
}
}
# Get which opponent strategy human current actn maps to (if index = 0 then human current action is br to level-0 comp_strat...)
indices <- which(br_hum %in% as.character(data[t,"h_action"]))
# THEN likelihood of current human action is just prior on opponent vec (haven't updated priors with curr opp act yet)
# if action is not predicted by any level-k OM, assume human chooses randomly with prob eps
if(length(indices) == 0){
lik_hum[t] <- eps/nopts
# if same br action for multiple possible ai opponents, add probabilities
} else {
lik_hum[t] <- sum(opp_prior_vec[indices])*(1-eps) + eps/nopts
}
# Standardising the probabilities and updating prior
lik_opp[,t] <- lik_opp[,t]/sum(lik_opp[,t])
opp_prior_vec <- lik_opp[,t]
}
# for debugging uncomment the line below
#cat(as.character(pred_opp),as.character(data[t,"a_action"]),lik_opp[,t],"\n")
}
if(return_value == "-2loglik") {
ret <- -2*sum(log(lik_hum))
if(is.infinite(ret) || is.nan(ret)) {
return(1e+300)
} else {
return(ret)
}
}
if(return_value == "likelihood_by_trial") return(lik_hum)
}
# data = subset(dat,human_id == "38VxtUSv_h6RR5-tAAA2")
# naive_bayes(c(0.9,0.99),data,c("level0","level1","level2"),"-2loglik",FALSE)
rps_predict_opp <- read.csv("rps_predict_opp.csv")
red_opp <- filter(rps_predict_opp, rps_predict_opp$human_previous == "R" & rps_predict_opp$computer_previous == "S")
as.character(red_opp[["level0"]])
TR_bayes_modelling <- list()
for(id in unique(dat$human_id)) {
TR_bayes_modelling[[id]] <- list()
tdat <- subset(dat,human_id == id)
# TR_bayes_modelling[[id]] <- DEoptim(fn=naive_bayes, lower = c(0,0), upper = c(1,1), data=tdat, opp_strategy_vec = c("level0","level1","level2") ,return_value = "-2loglik", opp_mod_transfer = TRUE, control=list(trace = FALSE, parallelType=1,parVar = c("best_response")))
TR_bayes_modelling[[id]] <- optim(c(0.1,0.1),fn=naive_bayes,gr = NULL, data=tdat,opp_strategy_vec = c("level0","level1","level2"),return_value = "-2loglik", opp_mod_transfer = TRUE,lower = c(0.01,0.01), upper = c(0.99,0.99), method="L-BFGS-B")
}
save(TR_bayes_modelling,file="TR_bayes_modelling.RData")
NT_bayes_modelling <- list()
for(id in unique(dat$human_id)) {
NT_bayes_modelling[[id]] <- list()
tdat <- subset(dat,human_id == id)
# NT_bayes_modelling[[id]] <- DEoptim(fn=naive_bayes, lower = c(0.0,0.0), upper = c(1.0,1.0), data=tdat, opp_strategy_vec = c("level0","level1","level2"),return_value = "-2loglik", opp_mod_transfer = FALSE, control=list(trace = FALSE, parallelType=0,parVar = c("best_response")))
NT_bayes_modelling[[id]] <- optim(c(0.1,0.1),fn=naive_bayes,gr = NULL, data=tdat,opp_strategy_vec = c("level0","level1","level2"),return_value = "-2loglik", opp_mod_transfer = FALSE ,lower = c(0.01,0.01), upper = c(0.99,0.99), method="L-BFGS-B")
}
save(NT_bayes_modelling,file="NT_bayes_modelling.RData")
Nbayes_par_results <- data.frame()
for(id in unique(dat$human_id)) {
Nbayes_par_results <- rbind(Nbayes_par_results,
data.frame(
"id" = id,
"condition" = dat[dat$human_id==id,"condition"][1],
# BICs
"BIC_transfer" = TR_bayes_modelling[[id]]$value + 2*log(150),
"BIC_no_transfer" = NT_bayes_modelling[[id]]$value+ 2*log(150),
# Theta is the parameter governing AI stochasticity. Truth is 0.9
"theta_transfer" = TR_bayes_modelling[[id]]$par[1],
"theta_no_transfer" = NT_bayes_modelling[[id]]$par[1],
# Epsilone is parameter showing cases where human deviates from predictions about opponent (lower better)
"eps_transfer" = TR_bayes_modelling[[id]]$par[2],
"eps_no_transfer" = NT_bayes_modelling[[id]]$par[2]))
}
# Plotting the theta/eps scatter for all participants...
# plot(Nbayes_par_results$theta,Nbayes_par_results$eps,xlab="Theta", ylab= "Epsilone",col = ifelse(as.character(Nbayes_par_results$condition) == "Level2",'red','green'))
#
# write.csv(Nbayes_par_results,file="Nbayes_par_results.csv",row.names = FALSE)
# kable(Nbayes_par_results)
Nbayes_par_results <- data.frame()
for(id in unique(dat$human_id)) {
Nbayes_par_results <- rbind(Nbayes_par_results,
data.frame(
"id" = id,
"condition" = dat[dat$human_id==id,"condition"][1],
# BICs
"BIC_transfer" = TR_bayes_modelling[[id]]$value + 2*log(150),
"BIC_no_transfer" = NT_bayes_modelling[[id]]$value+ 2*log(150),
# Theta is the parameter governing AI stochasticity. Truth is 0.9
"theta_transfer" = TR_bayes_modelling[[id]]$par[1],
"theta_no_transfer" = NT_bayes_modelling[[id]]$par[1],
# Epsilone is parameter showing cases where human deviates from predictions about opponent (lower better)
"eps_transfer" = TR_bayes_modelling[[id]]$par[2],
"eps_no_transfer" = NT_bayes_modelling[[id]]$par[2]))
}
# Plotting the theta/eps scatter for all participants...
# plot(Nbayes_par_results$theta,Nbayes_par_results$eps,xlab="Theta", ylab= "Epsilone",col = ifelse(as.character(Nbayes_par_results$condition) == "Level2",'red','green'))
#
# write.csv(Nbayes_par_results,file="Nbayes_par_results.csv",row.names = FALSE)
# kable(Nbayes_par_results)
View(Nbayes_par_results)
All_results <- data.frame()
for(id in unique(dat$human_id)) {
All_results <- rbind(All_results,
data.frame(
"ID" = id,
"condition" = dat[dat$human_id==id,"condition"][1],
"Random_BIC" = -2*(100*log(1/3) + 50*log(1/5)),
# Bayesian updating with/without transfer
"Bayes_Tr_BIC" = TR_bayes_modelling[[id]]$value + 2*log(150),
"Bayes_No_Tr_BIC" = NT_bayes_modelling[[id]]$value+ 2*log(150),
# Theta is the parameter governing AI stochasticity. Truth is 0.9
"theta_transfer" = TR_bayes_modelling[[id]]$par[1],
"theta_no_transfer" = NT_bayes_modelling[[id]]$par[1],
# Epsilone is parameter showing cases where human deviates from predictions about opponent (lower better)
"eps_transfer" = TR_bayes_modelling[[id]]$par[2],
"eps_no_transfer" = NT_bayes_modelling[[id]]$par[2],
# Q-Learning
"QL_BIC" = QL_modelling[[id]]$value + 2*log(150),
# beta ->  inverse temperature parameter in softmax choice function
"QL_Beta" = QL_modelling[[id]]$par[1],
# alpha -> learning rate in QL update
"QL_alpha" = QL_modelling[[id]]$par[2],
# Q-learning with last round states
"QL_states_BIC" = QL_states_modelling[[id]]$optim$bestval + 2*log(150),
# beta ->  inverse temperature parameter in softmax choice function
"QL_states_Beta" = QL_states_modelling[[id]]$optim$bestmem[1],
# alpha -> learning rate in QL update
"QL_states_alpha" = QL_states_modelling[[id]]$optim$bestmem[2],
# Parametric EWA
# Parametric EWA BIC
"EWA_BIC" = EWA_modelling[[id]]$optim$bestval + 4*log(150),
"EWA_2LL" = EWA_modelling[[id]]$optim$bestval,
# Phi is depreciation of past attractions
"EWA_Phi" = EWA_modelling[[id]]$optim$bestmem[1],
# Delta is weight of foregone payoffs vs actual payoffs
"EWA_Delta" = EWA_modelling[[id]]$optim$bestmem[2],
# Rho is depreciation of the experience measure N(t)
"EWA_Rho" = EWA_modelling[[id]]$optim$bestmem[3],
#Lambda is a parameter of the softmax choice function (inverse Temperature)
"EWA_Lambda" = EWA_modelling[[id]]$optim$bestmem[4],
# Self-Tuning EWA (only 1 parameter)
# Parametric EWA BIC
"EWA_self_2LL" = EWA_self_modelling[[id]]$optim$bestval,
"EWA_self_BIC" = EWA_self_modelling[[id]]$optim$bestval + 1*log(150),
#Lambda is a parameter of the softmax choice function (inverse Temperature)
"EWA_self_Lambda" = EWA_self_modelling[[id]]$optim$bestmem[1]
))
}
write.csv(All_results,file="All_results.csv",row.names = FALSE)
View(All_results)
Table_results <- table(All_results[, "condition"],c("random","Bayes Tr","Bayes No Tr","QL", "QL_states","EWA","S_EWA")[apply(All_results[,c("Random_BIC","Bayes_Tr_BIC","Bayes_No_Tr_BIC","QL_BIC","QL_states_BIC","EWA_BIC","EWA_self_BIC")],1,which.min)])
write.csv(Table_results,file="Table_results.csv",row.names = TRUE)
kable(Table_results)
Corr_Tr_model <- data.frame()
for(id in unique(dat$human_id)) {
tdat <- subset(dat,human_id == id)
tot_score <- sum(tdat$score)
tot_time <- sum(tdat$human_rt)
early_dat <- subset(tdat,between(tdat$round,2,11) & (game =="fwg" | game =="numbers") )
tr_score <- sum(early_dat$score)
id_results <- subset(All_results, ID == id)
min_BIC <- apply(id_results[,c("Random_BIC","Bayes_Tr_BIC","Bayes_No_Tr_BIC","QL_BIC","QL_states_BIC","EWA_BIC","EWA_self_BIC")],1,min)
best_model <- c("random","Bayes Tr","Bayes No Tr","QL", "QL_states","EWA","S_EWA")[apply(id_results[,c("Random_BIC","Bayes_Tr_BIC","Bayes_No_Tr_BIC","QL_BIC","QL_states_BIC","EWA_BIC","EWA_self_BIC")],1,which.min)]
#
Corr_Tr_model <- rbind(Corr_Tr_model ,
data.frame(
"id" = id,
"condition" = dat[dat$human_id==id,"condition"][1],
"Early_game_score" = tr_score,
"Total_score" = tot_score,
"Best_model" = best_model,
"Total_time" = sum(tdat$human_rt),
"TR_minus_NT_BIC" = id_results[,"Bayes_Tr_BIC"] - id_results[,"Bayes_No_Tr_BIC"],
"Rand_minus_best_BIC" =  id_results[,"Random_BIC"] - min_BIC
))
}
cor.test(Corr_Tr_model$TR_minus_NT_BIC,Corr_Tr_model$Early_game_score, method="spearman")
cor.test(Corr_Tr_model$Rand_minus_best_BIC, Corr_Tr_model$Early_game_score, method="spearman")
View(Corr_Tr_model)
Corr_Tr_model <- data.frame()
for(id in unique(dat$human_id)) {
tdat <- subset(dat,human_id == id)
tot_score <- sum(tdat$score)
tot_time <- sum(tdat$human_rt)
early_dat <- subset(tdat,between(tdat$round,2,6) & (game =="fwg" | game =="numbers") )
tr_score <- sum(early_dat$score)
id_results <- subset(All_results, ID == id)
min_BIC <- apply(id_results[,c("Random_BIC","Bayes_Tr_BIC","Bayes_No_Tr_BIC","QL_BIC","QL_states_BIC","EWA_BIC","EWA_self_BIC")],1,min)
best_model <- c("random","Bayes Tr","Bayes No Tr","QL", "QL_states","EWA","S_EWA")[apply(id_results[,c("Random_BIC","Bayes_Tr_BIC","Bayes_No_Tr_BIC","QL_BIC","QL_states_BIC","EWA_BIC","EWA_self_BIC")],1,which.min)]
#
Corr_Tr_model <- rbind(Corr_Tr_model ,
data.frame(
"id" = id,
"condition" = dat[dat$human_id==id,"condition"][1],
"Early_game_score" = tr_score,
"Total_score" = tot_score,
"Best_model" = best_model,
"Total_time" = sum(tdat$human_rt),
"TR_minus_NT_BIC" = id_results[,"Bayes_Tr_BIC"] - id_results[,"Bayes_No_Tr_BIC"],
"Rand_minus_best_BIC" =  id_results[,"Random_BIC"] - min_BIC
))
}
hist(Corr_Tr_model$Best_model)
barplot(prop.table(table(Corr_Tr_model$Best_model)))
version()
version
barplot(prop.table(table(Corr_Tr_model$model)))
barplot(table(Corr_Tr_model$Best_model))
plot(Nbayes_par_results$theta,Nbayes_par_results$eps,xlab="Theta", ylab= "Epsilone",col = ifelse(as.character(Nbayes_par_results$condition) == "Level2",'red','green'))
