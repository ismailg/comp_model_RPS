}
# Standardising the probabilities and updating prior
lik[,t] = lik[,t]/sum(lik[,t])
prior_vec = lik[,t]
}
# for debugging uncomment the line below
#cat(as.character(pred),as.character(data[t,"h_action"]),lik[,t],"\n")
}
if(return_value == "posterior") {
ret <- lik[ ,nrow(data)]
#if(ret == Inf) {
# return(1e+300)
#} else {
return(ret)
#}
}
if(return_value == "likelihood_by_trial") return(lik)
}
test_modelling <- list()
fixed_par = 0.9
for(id in unique(dat$human_id)) {
test_modelling[[id]] <- list()
tdat <- subset(dat,human_id == id)
strats = c("level1","level2","level3","WSLS")
posteriors <- modelLL(fixed_par,tdat,strats,return_value="posterior")
#for (k in 1:4) {
#test_modelling[[id]]$temp_name <- optim(0.5,fn=modelLL,data =tdat,strategy_vec = c("level1","level2","level3","WSLS"), rank = k,  method = "Brent", lower = 0.4 , upper =0.6 )
names(test_modelling[[id]]) <- strats
}
test_modelling <- list()
fixed_par = 0.9
for(id in unique(dat$human_id)) {
test_modelling[[id]] <- list()
tdat <- subset(dat,human_id == id)
strats = c("level1","level2","level3","WSLS")
posteriors <- modelLL(fixed_par,tdat,strats,return_value="posterior")
print(length(posteriors))
#for (k in 1:4) {
#test_modelling[[id]]$temp_name <- optim(0.5,fn=modelLL,data =tdat,strategy_vec = c("level1","level2","level3","WSLS"), rank = k,  method = "Brent", lower = 0.4 , upper =0.6 )
names(test_modelling[[id]]) <- strats
}
test_modelling <- list()
fixed_par = 0.9
for(id in unique(dat$human_id)) {
test_modelling[[id]] <- list()
tdat <- subset(dat,human_id == id)
strats = c("level1","level2","level3","WSLS")
test_modelling[[id]]$posteriors <- modelLL(fixed_par,tdat,strats,return_value="posterior")
print(length(posteriors))
#for (k in 1:4) {
#test_modelling[[id]]$temp_name <- optim(0.5,fn=modelLL,data =tdat,strategy_vec = c("level1","level2","level3","WSLS"), rank = k,  method = "Brent", lower = 0.4 , upper =0.6 )
names(test_modelling[[id]]) <- strats
}
test_modelling <- list()
fixed_par = 0.9
for(id in unique(dat$human_id)) {
test_modelling[[id]] <- list()
tdat <- subset(dat,human_id == id)
strats = c("level1","level2","level3","WSLS")
test_modelling[[id]]$posteriors <- modelLL(fixed_par,tdat,strats,return_value="posterior")
print(length(posteriors))
#for (k in 1:4) {
#test_modelling[[id]]$temp_name <- optim(0.5,fn=modelLL,data =tdat,strategy_vec = c("level1","level2","level3","WSLS"), rank = k,  method = "Brent", lower = 0.4 , upper =0.6 )
names(test_modelling[[id]]$posteriors) <- strats
}
save(test_modelling,file="test_modelling.RData")
View(test_modelling)
test_modelling <- list()
fixed_par = 0.9
for(id in unique(dat$human_id)) {
test_modelling[[id]] <- list()
tdat <- subset(dat,human_id == id)
strats = c("level1","level2","level3","WSLS")
test_modelling[[id]] <- modelLL(fixed_par,tdat,strats,return_value="posterior")
names(test_modelling[[id]]) <- strats
#for (k in 1:4) {
#test_modelling[[id]]$temp_name <- optim(0.5,fn=modelLL,data =tdat,strategy_vec = c("level1","level2","level3","WSLS"), rank = k,  method = "Brent", lower = 0.4 , upper =0.6 )
}
save(test_modelling,file="test_modelling.RData")
View(test_modelling)
test_modelling <- list()
fixed_par = 0.5
for(id in unique(dat$human_id)) {
test_modelling[[id]] <- list()
tdat <- subset(dat,human_id == id)
strats = c("level1","level2","level3","WSLS")
test_modelling[[id]] <- modelLL(fixed_par,tdat,strats,return_value="posterior")
names(test_modelling[[id]]) <- strats
#for (k in 1:4) {
#test_modelling[[id]]$temp_name <- optim(0.5,fn=modelLL,data =tdat,strategy_vec = c("level1","level2","level3","WSLS"), rank = k,  method = "Brent", lower = 0.4 , upper =0.6 )
}
save(test_modelling,file="test_modelling.RData")
View(test_modelling)
test_modelling <- list()
fixed_par = 0.1
for(id in unique(dat$human_id)) {
test_modelling[[id]] <- list()
tdat <- subset(dat,human_id == id)
strats = c("level1","level2","level3","WSLS")
test_modelling[[id]] <- modelLL(fixed_par,tdat,strats,return_value="posterior")
names(test_modelling[[id]]) <- strats
#for (k in 1:4) {
#test_modelling[[id]]$temp_name <- optim(0.5,fn=modelLL,data =tdat,strategy_vec = c("level1","level2","level3","WSLS"), rank = k,  method = "Brent", lower = 0.4 , upper =0.6 )
}
save(test_modelling,file="test_modelling.RData")
View(test_modelling)
test_modelling <- list()
fixed_par = 0.9
for(id in unique(dat$human_id)) {
test_modelling[[id]] <- list()
tdat <- subset(dat,human_id == id)
strats = c("level1","level2","level3","WSLS")
test_modelling[[id]] <- modelLL(fixed_par,tdat,strats,return_value="posterior")
names(test_modelling[[id]]) <- strats
#for (k in 1:4) {
#test_modelling[[id]]$temp_name <- optim(0.5,fn=modelLL,data =tdat,strategy_vec = c("level1","level2","level3","WSLS"), rank = k,  method = "Brent", lower = 0.4 , upper =0.6 )
}
save(test_modelling,file="test_modelling.RData")
View(test_modelling)
View(test_modelling)
View(dat)
naive_bayes <- function(par,data,strategy_vec,return_value=c("posterior","likelihood_by_trial")) {
# par = parameter vector (has 4 elements, one parameter for each strategy)
# dat = data subset for one participant
# strategy = c("level1","level2","level3","WSLS")
# rank = 1, 2 3 or 4. Which of the strategies are we evaluating likelihood for?
# return = -2logLik vector of 4 elements, one for each strat (default, for use in optimization)
# or "likelihood_by_trial" vector  (for later plotting, etc)
return_value <- match.arg(return_value)
theta <- par[1]
num_strat = length(strategy_vec)
# set up a vector to store the likelihood
lik <- matrix(0.0 ,num_strat, nrow(data))
# Initiate prior vector as uniform
prior_vec <-rep(1/num_strat, num_strat)
for(t in 1:nrow(data)) {
t_game <- data[t,"game"]
pred_file <- switch(as.character(t_game),rps=rps_predict,fwg = fwg_predict, numbers = numbers_predict)
if(t_game == "numbers") nopts <- 5 else nopts <- 3
if(data[t,"round"] == 1) {
# first round is uniform prediction
pred <- NA
lik[,t] <- prior_vec
} else {
# get prediction from file
for (strategy in strategy_vec) {
k = match(strategy,strategy_vec)
pred <- as.character(filter(pred_file,human_previous == as.character(data[t-1,"h_action"]) & computer_previous == as.character(data[t-1,"a_action"]))[strategy][1,])
# Multiply prior by likelihood of observation to get posterior
if(as.character(data[t,"h_action"]) == pred) {
lik[k,t] <- (theta + (1-theta)/nopts)*prior_vec[k]
} else {
lik[k,t] <- ((1-theta)/nopts)*prior_vec[k]
}
}
# Standardising the probabilities and updating prior
lik[,t] = lik[,t]/sum(lik[,t])
prior_vec = lik[,t]
}
# for debugging uncomment the line below
#cat(as.character(pred),as.character(data[t,"h_action"]),lik[,t],"\n")
}
if(return_value == "posterior") {
ret <- lik[ ,nrow(data)]
#if(ret == Inf) {
# return(1e+300)
#} else {
return(ret)
#}
}
if(return_value == "likelihood_by_trial") return(lik)
}
test_modelling <- list()
fixed_par = 0.9
for(id in unique(dat$human_id)) {
test_modelling[[id]] <- list()
tdat <- subset(dat,human_id == id)
strats = c("level1","level2","level3","WSLS")
naive_bayes_modelling[[id]] <- naive_bayes(fixed_par,tdat,strats,return_value="posterior")
names(naive_bayes_modelling[[id]]) <- strats
}
test_modelling <- list()
fixed_par = 0.9
for(id in unique(dat$human_id)) {
naive_bayes_modelling[[id]] <- list()
tdat <- subset(dat,human_id == id)
strats = c("level1","level2","level3","WSLS")
naive_bayes_modelling[[id]] <- naive_bayes(fixed_par,tdat,strats,return_value="posterior")
names(naive_bayes_modelling[[id]]) <- strats
}
naive_bayes_modelling <- list()
fixed_par = 0.9
for(id in unique(dat$human_id)) {
naive_bayes_modelling[[id]] <- list()
tdat <- subset(dat,human_id == id)
strats = c("level1","level2","level3","WSLS")
naive_bayes_modelling[[id]] <- naive_bayes(fixed_par,tdat,strats,return_value="posterior")
names(naive_bayes_modelling[[id]]) <- strats
}
save(naive_bayes_modelling,file="naive_bayes_modelling.RData")
View(naive_bayes_modelling)
best_response <- function(game,ai_action){
if (game == "RPS"){
if (ai_action == "R") {return("P")}
else if (ai_action == "P") {return("S")}
else if (ai_action == "S") {return("R")}
} else if (game == "FWG"){
if (ai_action == "F") {return("W")}
else if (ai_action == "W") {return("G")}
else if (ai_action == "G") {return("F")}
} else if (game == "NUM") {
if (ai_action == "1") {return("2")}
else if (ai_action == "2") {return("3")}
else if (ai_action == "3") {return("4")}
else if (ai_action == "4") {return("5")}
else if (ai_action == "5") {return("1")}
}
}
naive_bayes <- function(par,data,opp_strategy_vec,return_value=c("posterior","likelihood_by_trial")) {
# par = parameter vector (has 4 elements, one parameter for each strategy)
# dat = data subset for one participant
# opp_strategy_vec = c("level0","level1","level2")
# hum_strategy_vec = c("level1","level2","level3")
# return = -2logLik vector of 4 elements, one for each strat (default, for use in optimization)
# or "likelihood_by_trial" vector  (for later plotting, etc)
return_value <- match.arg(return_value)
theta <- par[1]
num_strat = length(opp_strategy_vec)
# set up a vector to store the likelihood
lik_opp <- matrix(0.0,num_strat, nrow(data))
lik_hum <- matrix(0.0,nrow(data))
# Initiate prior vector as uniform
opp_prior_vec <-rep(1/num_strat, num_strat)
for(t in 1:nrow(data)) {
t_game <- data[t,"game"]
pred_file_opp <- switch(as.character(t_game),rps=rps_predict_opp,fwg = fwg_predict_opp, numbers = numbers_predict_opp)
if(t_game == "numbers") nopts <- 5 else nopts <- 3
if(data[t,"round"] == 1) {
# first round is uniform prediction
pred <- NA
lik_opp[,t] <- opp_prior_vec
} else {
# get prediction of opponent action from CSV files
for (strategy in opp_strategy_vec) {
k = match(strategy,opp_strategy_vec)
pred_opp <- as.character(filter(pred_file_opp,human_previous == as.character(data[t-1,"h_action"]) & computer_previous == as.character(data[t-1,"a_action"]))[strategy][1,])
# Given opponent action predicted, what would be human action best response for each opp strat
br_hum[k] <- best_response(t_game,pred_opp)
# Multiply prior by likelihood of observation to get posterior
if(as.character(data[t,"a_action"]) == pred_opp) {
lik_opp[k,t] <- (theta + (1-theta)/nopts)*opp_prior_vec[k]
} else {
lik[k,t] <- ((1-theta)/nopts)*opp_prior_vec[k]
}
}
# Get which opponent strategy human current actn maps to (if index = 0 then human current action is br to level-0 comp_strat...)
# ...assumes this is unique. check
index <- match(as.character(data[t,"h_action"]),br_hum)
# THEN likelihood of current human action is just prior on opponent vec (haven't updated priors with curr opp act yet)
lik_hum[t] = opp_prior_vec[index]
# Standardising the probabilities and updating prior
lik_opp[,t] = lik_opp[,t]/sum(lik_opp[,t])
opp_prior_vec = lik[,t]
}
# for debugging uncomment the line below
#cat(as.character(pred),as.character(data[t,"h_action"]),lik[,t],"\n")
}
if(return_value == "-2loglike") {
ret <- -2*sum(log(lik_hum))
if(ret == Inf) {
return(1e+300)
} else {
return(ret)
}
}
if(return_value == "likelihood_by_trial") return(lik_hum)
}
library(knitr)
knitr::opts_chunk$set(echo = TRUE)
#dat <- read.csv("data20180719.csv")
dat <- read.csv("test_data.csv")
# using some functions from the 'tidyverse' (also for me to get use to them ;-)
library(tidyr)
library(dplyr)
# transform 'winner' variable in numeric score
dat$score <- recode(dat$winner, human = 1, tie = 0, ai = -1)
# create a new variable 'block' with round 1...25 = block 1 and round 26...50 as block 2
dat$block <- as.numeric(cut(dat$round,2))
# create a new data.frame in a 'wide format'
widedata <- dat %>%
unite(game_block,game,block) %>% # this creates a new variable which combines game and block
group_by(human_id,condition,game_block) %>% # let the functions know you want to separate things by ID, condition, and game_block
summarize(mean_score = mean(score)) %>% # compute average score (i.e wins - losses)
spread(game_block,mean_score) # reformat in the 'wide' format
# save the data file as a .csv to use in e.g. SPSS
write.csv(widedata,row.names=FALSE,file="scores_wide.csv")
# read in the various files which
rps_predict <- read.csv("rps_predict.csv")
fwg_predict <- read.csv("fwg_predict.csv")
numbers_predict <- read.csv("numbers_predict.csv")
# recode actions to make them equal to the codes in these files
dat$h_action <- recode(dat$human_action,"rock" = "R", "paper" = "P", "scissors" = "S", "fire" = "F", "water" = "W", "grass" = "G", "one" = "1", "two" = "2", "three" = "3", "four" = "4", "five" = "5")
dat$a_action <- recode(dat$ai_action,"rock" = "R", "paper" = "P", "scissors" = "S", "fire" = "F", "water" = "W", "grass" = "G", "one" = "1", "two" = "2", "three" = "3", "four" = "4", "five" = "5")
# logit tranformation
my_logit <- function(x) {
ret <- log(x/(1-x))
ret[x==0] <- -Inf
ret[x==1] <- Inf
return(ret)
}
# inverse logit transformation
my_logistic <- function(x) {
ret <- 1/(1+exp(-x))
ret[x == -Inf] <- 0.0
ret[x == Inf] <- 1.0
return(ret)
}
best_response <- function(game,ai_action){
if (game == "RPS"){
if (ai_action == "R") {return("P")}
else if (ai_action == "P") {return("S")}
else if (ai_action == "S") {return("R")}
} else if (game == "FWG"){
if (ai_action == "F") {return("W")}
else if (ai_action == "W") {return("G")}
else if (ai_action == "G") {return("F")}
} else if (game == "NUM") {
if (ai_action == "1") {return("2")}
else if (ai_action == "2") {return("3")}
else if (ai_action == "3") {return("4")}
else if (ai_action == "4") {return("5")}
else if (ai_action == "5") {return("1")}
}
}
naive_bayes <- function(par,data,opp_strategy_vec,return_value=c("-2loglik","likelihood_by_trial")) {
# par = parameter vector (has 4 elements, one parameter for each strategy)
# dat = data subset for one participant
# opp_strategy_vec = c("level0","level1","level2")
# hum_strategy_vec = c("level1","level2","level3")
# return = -2logLik vector of 4 elements, one for each strat (default, for use in optimization)
# or "likelihood_by_trial" vector  (for later plotting, etc)
return_value <- match.arg(return_value)
theta <- par[1]
num_strat = length(opp_strategy_vec)
# set up a vector to store the likelihood
lik_opp <- matrix(0.0,num_strat, nrow(data))
lik_hum <- matrix(0.0,nrow(data))
# Initiate prior vector as uniform
opp_prior_vec <-rep(1/num_strat, num_strat)
for(t in 1:nrow(data)) {
t_game <- data[t,"game"]
pred_file_opp <- switch(as.character(t_game),rps=rps_predict_opp,fwg = fwg_predict_opp, numbers = numbers_predict_opp)
if(t_game == "numbers") nopts <- 5 else nopts <- 3
if(data[t,"round"] == 1) {
# first round is uniform prediction
pred <- NA
lik_opp[,t] <- opp_prior_vec
} else {
# get prediction of opponent action from CSV files
for (strategy in opp_strategy_vec) {
k = match(strategy,opp_strategy_vec)
pred_opp <- as.character(filter(pred_file_opp,human_previous == as.character(data[t-1,"h_action"]) & computer_previous == as.character(data[t-1,"a_action"]))[strategy][1,])
# Given opponent action predicted, what would be human action best response for each opp strat
br_hum[k] <- best_response(t_game,pred_opp)
# Multiply prior by likelihood of observation to get posterior
if(as.character(data[t,"a_action"]) == pred_opp) {
lik_opp[k,t] <- (theta + (1-theta)/nopts)*opp_prior_vec[k]
} else {
lik_opp[k,t] <- ((1-theta)/nopts)*opp_prior_vec[k]
}
}
# Get which opponent strategy human current actn maps to (if index = 0 then human current action is br to level-0 comp_strat...)
# NOTE!! -> ...assumes this is unique. check
index <- match(as.character(data[t,"h_action"]),br_hum)
# THEN likelihood of current human action is just prior on opponent vec (haven't updated priors with curr opp act yet)
lik_hum[t] = opp_prior_vec[index]
# Standardising the probabilities and updating prior
lik_opp[,t] = lik_opp[,t]/sum(lik_opp[,t])
opp_prior_vec = lik_opp[,t]
}
# for debugging uncomment the line below
#cat(as.character(pred_opp),as.character(data[t,"h_action"]),lik[,t],"\n")
}
if(return_value == "-2loglik") {
ret <- -2*sum(log(lik_hum))
if(ret == Inf) {
return(1e+300)
} else {
return(ret)
}
}
if(return_value == "likelihood_by_trial") return(lik_hum)
}
naive_bayes_modelling <- list()
for(id in unique(dat$human_id)) {
naive_bayes_modelling[[id]] <- list()
tdat <- subset(dat,human_id == id)
opp_strats = c("level0","level1","level2")
naive_bayes_modelling[[id]] <- optimize(naive_bayes,interval=c(0,1),data=tdat,c("level0","level1","level2"), "-2loglike")
}
naive_bayes_modelling <- list()
for(id in unique(dat$human_id)) {
naive_bayes_modelling[[id]] <- list()
tdat <- subset(dat,human_id == id)
opp_strats = c("level0","level1","level2")
naive_bayes_modelling[[id]] <- optimize(naive_bayes,interval=c(0,1),data=tdat,c("level0","level1","level2"), "-2loglik")
}
naive_bayes_modelling <- list()
for(id in unique(dat$human_id)) {
naive_bayes_modelling[[id]] <- list()
tdat <- subset(dat,human_id == id)
opp_strats = c("level0","level1","level2")
naive_bayes_modelling[[id]] <- optimize(naive_bayes,interval=c(0,1),data=tdat,c("level0","level1","level2"), "-2loglik")
}
best_response <- function(game,ai_action){
if (game == "RPS"){
if (ai_action == "R") {return("P")}
else if (ai_action == "P") {return("S")}
else if (ai_action == "S") {return("R")}
} else if (game == "FWG"){
if (ai_action == "F") {return("W")}
else if (ai_action == "W") {return("G")}
else if (ai_action == "G") {return("F")}
} else if (game == "NUM") {
if (ai_action == "1") {return("2")}
else if (ai_action == "2") {return("3")}
else if (ai_action == "3") {return("4")}
else if (ai_action == "4") {return("5")}
else if (ai_action == "5") {return("1")}
}
}
naive_bayes <- function(par,data,opp_strategy_vec,return_value=c("-2loglik","likelihood_by_trial")) {
# par = parameter vector (has 4 elements, one parameter for each strategy)
# dat = data subset for one participant
# opp_strategy_vec = c("level0","level1","level2")
# hum_strategy_vec = c("level1","level2","level3")
# return = -2logLik vector of 4 elements, one for each strat (default, for use in optimization)
# or "likelihood_by_trial" vector  (for later plotting, etc)
return_value <- match.arg(return_value)
theta <- par[1]
num_strat = length(opp_strategy_vec)
# set up a vector to store the likelihood
lik_opp <- matrix(0.0,num_strat, nrow(data))
lik_hum <- matrix(0.0,nrow(data))
# Initiate prior vector as uniform
opp_prior_vec <-rep(1/num_strat, num_strat)
for(t in 1:nrow(data)) {
t_game <- data[t,"game"]
pred_file_opp <- switch(as.character(t_game),rps = rps_predict_opp,fwg = fwg_predict_opp, numbers = numbers_predict_opp)
if(t_game == "numbers") nopts <- 5 else nopts <- 3
if(data[t,"round"] == 1) {
# first round is uniform prediction
pred <- NA
lik_opp[,t] <- opp_prior_vec
} else {
# get prediction of opponent action from CSV files
for (strategy in opp_strategy_vec) {
k = match(strategy,opp_strategy_vec)
pred_opp <- as.character(filter(pred_file_opp,human_previous == as.character(data[t-1,"h_action"]) & computer_previous == as.character(data[t-1,"a_action"]))[strategy][1,])
# Given opponent action predicted, what would be human action best response for each opp strat
br_hum[k] <- best_response(t_game,pred_opp)
# Multiply prior by likelihood of observation to get posterior
if(as.character(data[t,"a_action"]) == pred_opp) {
lik_opp[k,t] <- (theta + (1-theta)/nopts)*opp_prior_vec[k]
} else {
lik_opp[k,t] <- ((1-theta)/nopts)*opp_prior_vec[k]
}
}
# Get which opponent strategy human current actn maps to (if index = 0 then human current action is br to level-0 comp_strat...)
# NOTE!! -> ...assumes this is unique. check
index <- match(as.character(data[t,"h_action"]),br_hum)
# THEN likelihood of current human action is just prior on opponent vec (haven't updated priors with curr opp act yet)
lik_hum[t] = opp_prior_vec[index]
# Standardising the probabilities and updating prior
lik_opp[,t] = lik_opp[,t]/sum(lik_opp[,t])
opp_prior_vec = lik_opp[,t]
}
# for debugging uncomment the line below
#cat(as.character(pred_opp),as.character(data[t,"h_action"]),lik[,t],"\n")
}
if(return_value == "-2loglik") {
ret <- -2*sum(log(lik_hum))
if(ret == Inf) {
return(1e+300)
} else {
return(ret)
}
}
if(return_value == "likelihood_by_trial") return(lik_hum)
}
naive_bayes_modelling <- list()
for(id in unique(dat$human_id)) {
naive_bayes_modelling[[id]] <- list()
tdat <- subset(dat,human_id == id)
opp_strats = c("level0","level1","level2")
naive_bayes_modelling[[id]] <- optimize(naive_bayes,interval=c(0,1),data=tdat,c("level0","level1","level2"), "-2loglik")
}
naive_bayes_modelling <- list()
for(id in unique(dat$human_id)) {
naive_bayes_modelling[[id]] <- list()
tdat <- subset(dat,human_id == id)
opp_strats = c("level0","level1","level2")
naive_bayes_modelling[[id]] <- optimize(naive_bayes,interval=c(0,1),data=tdat,c("level0","level1","level2"), "-2loglik")
}
library(knitr)
knitr::opts_chunk$set(echo = TRUE)
x <- expand.grid(c('R', 'P', 'S'), 2)
cat(as.character(x))
x <- c('R', 'P', 'S')
do.call(expand.grid, rep(list(x), 3))
x <- c('R', 'P', 'S')
do.call(expand.grid, rep(list(x), 2))
