dat <- dat %>%
mutate(
loglik = case_when(
human_action_num == 1 ~ log(p_self_a1),
human_action_num == 2 ~ log(p_self_a2),
human_action_num == 3 ~ log(p_self_a3),
human_action_num == 4 ~ log(p_self_a4),
human_action_num == 5 ~ log(p_self_a5))
)
#cat(as.character(exp(dat$loglik)), "\n", "\n")
ret <- -2*sum(dat$loglik)
if(is.infinite(ret) || is.nan(ret)) {
#return(1e+300)
return(dat)
} else {
#return(ret)
return(dat)
}
# return(-2*sum(dat$loglik))
}
results_dat <- exp1_Bayes_model_LL(0.7,data = dat, generalize = "game")
# group data by subjective component id
# if human generalizes over games, we can run update the prior generally
# if human does not generalize, we need to reset the prior at the start of each ?stage?
exp1_Bayes_model_LL <- function(par,data, generalize = c("game","no")) {
# data is a subset for a single participant
generalize <- match.arg(generalize)
alpha <- par[1] # probability that ai opponent plays according to strategy
if(length(par) > 1) {
beta <- par[2] # probability that human plays according to best response
} else{
beta <- 1 # probability that human plays according to best response
}
prior <- c(1,1,1) # prior alpha for dirichlet on p(level)
prior <- prior/sum(prior)
# use alpha to change the "deterministic" predictions
# apply to actions 4 and 5
# make_probs_2 <- function(x) {
#   for (t in (1:nrow(data))) {
#     current_game <- data$game[t]
#     if (data$game == "rps" | data$game == "fwg") {
#       0
#     } else {
#       (1-alpha)*(1/5) + alpha*x
#     }
#   }
# }
#
# # apply to actions 1 to 3
# make_probs_1 <- function(x,data) {
#   for (t in (1:nrow(data))) {
#     current_game <- data$game[t]
#     if (current_game == "rps" | current_game == "fwg") {
#       return((1-alpha)*(1/3) + alpha*x)
#     } else {
#       return((1-alpha)*(1/5) + alpha*x)
#     }
#   }
# }
#  make_probs <- function(x) {
#   (1-alpha)*(1/3) + alpha*x
# }
#
#  make_probs_2 <- function(x) {
#   (1-alpha)*(1/5) + alpha*x
# }
# dat <- ungroup(data) %>%
#   mutate_at(.vars = vars(starts_with("pred_")), function(x) alpha*x + (1-alpha)/3)
dat <- ungroup(data) %>%
mutate_at(.vars = vars(c(starts_with("pred_a1"),starts_with("pred_a3"),starts_with("pred_a3"))),
funs (case_when(
game == "numbers" ~  alpha*. + (1-alpha)/5,
TRUE ~ alpha*. + (1-alpha)/3))) %>%
mutate_at(.vars = vars(c(starts_with("pred_a4"),starts_with("pred_a5"))),
funs (case_when(
game == "numbers" ~  alpha*. + (1-alpha)/5,
TRUE ~ 0)))
# dat <- ungroup(data) %>%
#   mutate_at(.vars = vars(starts_with("pred_")),
#            .funs = funs( . = case_when(
#         game =="rps" ~  (1-alpha)*(1/3) + .*alpha,
#         game == "numbers" ~ (1-alpha)*(1/5) + .*alpha)))
# mutate_at(vars(starts_with("pred_") & (contains("a1") | contains("a2") | contains("a3"))),make_probs_1,dat$game)
if(generalize == "no") {
# group by game and stage
dat <- group_by(dat,game,add=TRUE)
}
# compute likelihood of ai action
dat <- dat %>%
mutate(
lik_level0 = case_when(
ai_action_num == 1 ~ pred_a1_level0,
ai_action_num == 2 ~ pred_a2_level0,
ai_action_num == 3 ~ pred_a3_level0,
ai_action_num == 4 ~ pred_a4_level0,
ai_action_num == 5 ~ pred_a5_level0
),
lik_level1 = case_when(
ai_action_num == 1 ~ pred_a1_level1,
ai_action_num == 2 ~ pred_a2_level1,
ai_action_num == 3 ~ pred_a3_level1,
ai_action_num == 4 ~ pred_a4_level1,
ai_action_num == 5 ~ pred_a5_level1
),
lik_level2 = case_when(
ai_action_num == 1 ~ pred_a1_level2,
ai_action_num == 2 ~ pred_a2_level2,
ai_action_num == 3 ~ pred_a3_level2,
ai_action_num == 4 ~ pred_a4_level2,
ai_action_num == 5 ~ pred_a5_level2
)
)
# use likelihood to compute the posterior predictive probability of each level
dat <- dat %>%
mutate(logpost_level0 = lag(log(prior[1]) + cumsum(log(lik_level0)),default=log(prior[1])),
logpost_level1 = lag(log(prior[2]) + cumsum(log(lik_level1)),default=log(prior[2])),
logpost_level2 = lag(log(prior[3]) + cumsum(log(lik_level2)),default=log(prior[3]))) %>%
# you can add or subtract any constant from the log-likelihoods; this can aid in precision
mutate(min = pmin(logpost_level0,logpost_level1, logpost_level2)) %>%
mutate(normalize = exp(logpost_level0 - min) + exp(logpost_level1 - min) + exp(logpost_level2 - min)) %>%
mutate(post_level0 = exp(logpost_level0 - min)/normalize,
post_level1 = exp(logpost_level1 - min)/normalize,
post_level2 = exp(logpost_level2 - min)/normalize)
#cat(as.character(c(round(dat$post_level0,2), round(dat$post_level1,2), round(dat$post_level2,2)), "\n", "\n"))
# use posterior predictive probability to predict probability of each ai and then human action
# opp is ai and self is human player here
dat <- dat %>%
mutate(p_opp_a1 = post_level0*pred_a1_level0 + post_level1*pred_a1_level1 + post_level2*pred_a1_level2,
p_opp_a2 = post_level0*pred_a2_level0 + post_level1*pred_a2_level1 + post_level2*pred_a2_level2,
p_opp_a3 = post_level0*pred_a3_level0 + post_level1*pred_a3_level1 + post_level2*pred_a3_level2,
p_opp_a4 = post_level0*pred_a4_level0 + post_level1*pred_a4_level1 + post_level2*pred_a4_level2,
p_opp_a5 = post_level0*pred_a5_level0 + post_level1*pred_a5_level1 + post_level2*pred_a5_level2
) %>%
mutate(p_self_a1 = case_when(
game == "numbers" ~ (1-beta)*(1/3) + beta*p_opp_a5,
TRUE ~ (1-beta)*(1/3) + beta*(p_opp_a3)
),
p_self_a2 = case_when(
game == "numbers" ~ (1-beta)*(1/3) + beta*p_opp_a1,
TRUE ~ (1-beta)*(1/3) + beta*(p_opp_a1)
),
p_self_a3 = case_when(
game == "numbers" ~ (1-beta)*(1/3) + beta*p_opp_a2,
TRUE ~ (1-beta)*(1/3) + beta*(p_opp_a2)
),
p_self_a4 = case_when(
game == "numbers" ~ (1-beta)*(1/3) + beta*p_opp_a3,
TRUE ~ 0
),
p_self_a5 = case_when(
game == "numbers" ~ (1-beta)*(1/3) + beta*p_opp_a4,
TRUE ~ 0
)
)
# now finally compute the likelihood of human actions
dat <- dat %>%
mutate(
loglik = case_when(
human_action_num == 1 ~ log(p_self_a1),
human_action_num == 2 ~ log(p_self_a2),
human_action_num == 3 ~ log(p_self_a3),
human_action_num == 4 ~ log(p_self_a4),
human_action_num == 5 ~ log(p_self_a5))
)
#cat(as.character(exp(dat$loglik)), "\n", "\n")
ret <- -2*sum(dat$loglik)
if(is.infinite(ret) || is.nan(ret)) {
#return(1e+300)
return(dat)
} else {
#return(ret)
return(dat)
}
# return(-2*sum(dat$loglik))
}
results_dat <- exp1_Bayes_model_LL(0.7,data = dat, generalize = "game")
results_dat <- exp1_Bayes_model_LL(0,data = dat, generalize = "game")
# group data by subjective component id
# if human generalizes over games, we can run update the prior generally
# if human does not generalize, we need to reset the prior at the start of each ?stage?
exp1_Bayes_model_LL <- function(par,data, generalize = c("game","no")) {
# data is a subset for a single participant
generalize <- match.arg(generalize)
alpha <- par[1] # probability that ai opponent plays according to strategy
if(length(par) > 1) {
beta <- par[2] # probability that human plays according to best response
} else{
beta <- 1 # probability that human plays according to best response
}
prior <- c(1,1,1) # prior alpha for dirichlet on p(level)
prior <- prior/sum(prior)
# use alpha to change the "deterministic" predictions
# apply to actions 4 and 5
# make_probs_2 <- function(x) {
#   for (t in (1:nrow(data))) {
#     current_game <- data$game[t]
#     if (data$game == "rps" | data$game == "fwg") {
#       0
#     } else {
#       (1-alpha)*(1/5) + alpha*x
#     }
#   }
# }
#
# # apply to actions 1 to 3
# make_probs_1 <- function(x,data) {
#   for (t in (1:nrow(data))) {
#     current_game <- data$game[t]
#     if (current_game == "rps" | current_game == "fwg") {
#       return((1-alpha)*(1/3) + alpha*x)
#     } else {
#       return((1-alpha)*(1/5) + alpha*x)
#     }
#   }
# }
#  make_probs <- function(x) {
#   (1-alpha)*(1/3) + alpha*x
# }
#
#  make_probs_2 <- function(x) {
#   (1-alpha)*(1/5) + alpha*x
# }
# dat <- ungroup(data) %>%
#   mutate_at(.vars = vars(starts_with("pred_")), function(x) alpha*x + (1-alpha)/3)
dat <- ungroup(data) %>%
mutate_at(.vars = vars(c(starts_with("pred_a1"),starts_with("pred_a2"),starts_with("pred_a3"))),
funs (case_when(
game == "numbers" ~  alpha*. + (1-alpha)/5,
TRUE ~ alpha*. + (1-alpha)/3))) %>%
mutate_at(.vars = vars(c(starts_with("pred_a4"),starts_with("pred_a5"))),
funs (case_when(
game == "numbers" ~  alpha*. + (1-alpha)/5,
TRUE ~ 0)))
# dat <- ungroup(data) %>%
#   mutate_at(.vars = vars(starts_with("pred_")),
#            .funs = funs( . = case_when(
#         game =="rps" ~  (1-alpha)*(1/3) + .*alpha,
#         game == "numbers" ~ (1-alpha)*(1/5) + .*alpha)))
# mutate_at(vars(starts_with("pred_") & (contains("a1") | contains("a2") | contains("a3"))),make_probs_1,dat$game)
if(generalize == "no") {
# group by game and stage
dat <- group_by(dat,game,add=TRUE)
}
# compute likelihood of ai action
dat <- dat %>%
mutate(
lik_level0 = case_when(
ai_action_num == 1 ~ pred_a1_level0,
ai_action_num == 2 ~ pred_a2_level0,
ai_action_num == 3 ~ pred_a3_level0,
ai_action_num == 4 ~ pred_a4_level0,
ai_action_num == 5 ~ pred_a5_level0
),
lik_level1 = case_when(
ai_action_num == 1 ~ pred_a1_level1,
ai_action_num == 2 ~ pred_a2_level1,
ai_action_num == 3 ~ pred_a3_level1,
ai_action_num == 4 ~ pred_a4_level1,
ai_action_num == 5 ~ pred_a5_level1
),
lik_level2 = case_when(
ai_action_num == 1 ~ pred_a1_level2,
ai_action_num == 2 ~ pred_a2_level2,
ai_action_num == 3 ~ pred_a3_level2,
ai_action_num == 4 ~ pred_a4_level2,
ai_action_num == 5 ~ pred_a5_level2
)
)
# use likelihood to compute the posterior predictive probability of each level
dat <- dat %>%
mutate(logpost_level0 = lag(log(prior[1]) + cumsum(log(lik_level0)),default=log(prior[1])),
logpost_level1 = lag(log(prior[2]) + cumsum(log(lik_level1)),default=log(prior[2])),
logpost_level2 = lag(log(prior[3]) + cumsum(log(lik_level2)),default=log(prior[3]))) %>%
# you can add or subtract any constant from the log-likelihoods; this can aid in precision
mutate(min = pmin(logpost_level0,logpost_level1, logpost_level2)) %>%
mutate(normalize = exp(logpost_level0 - min) + exp(logpost_level1 - min) + exp(logpost_level2 - min)) %>%
mutate(post_level0 = exp(logpost_level0 - min)/normalize,
post_level1 = exp(logpost_level1 - min)/normalize,
post_level2 = exp(logpost_level2 - min)/normalize)
#cat(as.character(c(round(dat$post_level0,2), round(dat$post_level1,2), round(dat$post_level2,2)), "\n", "\n"))
# use posterior predictive probability to predict probability of each ai and then human action
# opp is ai and self is human player here
dat <- dat %>%
mutate(p_opp_a1 = post_level0*pred_a1_level0 + post_level1*pred_a1_level1 + post_level2*pred_a1_level2,
p_opp_a2 = post_level0*pred_a2_level0 + post_level1*pred_a2_level1 + post_level2*pred_a2_level2,
p_opp_a3 = post_level0*pred_a3_level0 + post_level1*pred_a3_level1 + post_level2*pred_a3_level2,
p_opp_a4 = post_level0*pred_a4_level0 + post_level1*pred_a4_level1 + post_level2*pred_a4_level2,
p_opp_a5 = post_level0*pred_a5_level0 + post_level1*pred_a5_level1 + post_level2*pred_a5_level2
) %>%
mutate(p_self_a1 = case_when(
game == "numbers" ~ (1-beta)*(1/3) + beta*p_opp_a5,
TRUE ~ (1-beta)*(1/3) + beta*(p_opp_a3)
),
p_self_a2 = case_when(
game == "numbers" ~ (1-beta)*(1/3) + beta*p_opp_a1,
TRUE ~ (1-beta)*(1/3) + beta*(p_opp_a1)
),
p_self_a3 = case_when(
game == "numbers" ~ (1-beta)*(1/3) + beta*p_opp_a2,
TRUE ~ (1-beta)*(1/3) + beta*(p_opp_a2)
),
p_self_a4 = case_when(
game == "numbers" ~ (1-beta)*(1/3) + beta*p_opp_a3,
TRUE ~ 0
),
p_self_a5 = case_when(
game == "numbers" ~ (1-beta)*(1/3) + beta*p_opp_a4,
TRUE ~ 0
)
)
# now finally compute the likelihood of human actions
dat <- dat %>%
mutate(
loglik = case_when(
human_action_num == 1 ~ log(p_self_a1),
human_action_num == 2 ~ log(p_self_a2),
human_action_num == 3 ~ log(p_self_a3),
human_action_num == 4 ~ log(p_self_a4),
human_action_num == 5 ~ log(p_self_a5))
)
#cat(as.character(exp(dat$loglik)), "\n", "\n")
ret <- -2*sum(dat$loglik)
if(is.infinite(ret) || is.nan(ret)) {
#return(1e+300)
return(dat)
} else {
#return(ret)
return(dat)
}
# return(-2*sum(dat$loglik))
}
results_dat <- exp1_Bayes_model_LL(0,data = dat, generalize = "game")
results_dat <- exp1_Bayes_model_LL(1,data = dat, generalize = "game")
results_dat <- exp1_Bayes_model_LL(0.6,data = dat, generalize = "game")
results_dat <- exp1_Bayes_model_LL(0.4,data = dat, generalize = "game")
results_dat <- exp1_Bayes_model_LL(0.4,data = dat, generalize = "game")
# group data by subjective component id
# if human generalizes over games, we can run update the prior generally
# if human does not generalize, we need to reset the prior at the start of each ?stage?
exp1_Bayes_model_LL <- function(par,data, generalize = c("game","no")) {
# data is a subset for a single participant
generalize <- match.arg(generalize)
alpha <- par[1] # probability that ai opponent plays according to strategy
if(length(par) > 1) {
beta <- par[2] # probability that human plays according to best response
} else{
beta <- 1 # probability that human plays according to best response
}
prior <- c(1,1,1) # prior alpha for dirichlet on p(level)
prior <- prior/sum(prior)
# use alpha to change the "deterministic" prediction
dat <- ungroup(data) %>%
mutate_at(.vars = vars(c(starts_with("pred_a1"),starts_with("pred_a2"),starts_with("pred_a3"))),
funs (case_when(
game == "numbers" ~  alpha*. + (1-alpha)/5,
TRUE ~ alpha*. + (1-alpha)/3))) %>%
mutate_at(.vars = vars(c(starts_with("pred_a4"),starts_with("pred_a5"))),
funs (case_when(
game == "numbers" ~  alpha*. + (1-alpha)/5,
TRUE ~ 0)))
if(generalize == "no") {
# group by game and stage
dat <- group_by(dat,game,add=TRUE)
}
# compute likelihood of ai action
dat <- dat %>%
mutate(
lik_level0 = case_when(
ai_action_num == 1 ~ pred_a1_level0,
ai_action_num == 2 ~ pred_a2_level0,
ai_action_num == 3 ~ pred_a3_level0,
ai_action_num == 4 ~ pred_a4_level0,
ai_action_num == 5 ~ pred_a5_level0
),
lik_level1 = case_when(
ai_action_num == 1 ~ pred_a1_level1,
ai_action_num == 2 ~ pred_a2_level1,
ai_action_num == 3 ~ pred_a3_level1,
ai_action_num == 4 ~ pred_a4_level1,
ai_action_num == 5 ~ pred_a5_level1
),
lik_level2 = case_when(
ai_action_num == 1 ~ pred_a1_level2,
ai_action_num == 2 ~ pred_a2_level2,
ai_action_num == 3 ~ pred_a3_level2,
ai_action_num == 4 ~ pred_a4_level2,
ai_action_num == 5 ~ pred_a5_level2
)
)
# use likelihood to compute the posterior predictive probability of each level
dat <- dat %>%
mutate(logpost_level0 = lag(log(prior[1]) + cumsum(log(lik_level0)),default=log(prior[1])),
logpost_level1 = lag(log(prior[2]) + cumsum(log(lik_level1)),default=log(prior[2])),
logpost_level2 = lag(log(prior[3]) + cumsum(log(lik_level2)),default=log(prior[3]))) %>%
# you can add or subtract any constant from the log-likelihoods; this can aid in precision
mutate(min = pmin(logpost_level0,logpost_level1, logpost_level2)) %>%
mutate(normalize = exp(logpost_level0 - min) + exp(logpost_level1 - min) + exp(logpost_level2 - min)) %>%
mutate(post_level0 = exp(logpost_level0 - min)/normalize,
post_level1 = exp(logpost_level1 - min)/normalize,
post_level2 = exp(logpost_level2 - min)/normalize)
#cat(as.character(c(round(dat$post_level0,2), round(dat$post_level1,2), round(dat$post_level2,2)), "\n", "\n"))
# use posterior predictive probability to predict probability of each ai and then human action
# opp is ai and self is human player here
dat <- dat %>%
mutate(p_opp_a1 = post_level0*pred_a1_level0 + post_level1*pred_a1_level1 + post_level2*pred_a1_level2,
p_opp_a2 = post_level0*pred_a2_level0 + post_level1*pred_a2_level1 + post_level2*pred_a2_level2,
p_opp_a3 = post_level0*pred_a3_level0 + post_level1*pred_a3_level1 + post_level2*pred_a3_level2,
p_opp_a4 = post_level0*pred_a4_level0 + post_level1*pred_a4_level1 + post_level2*pred_a4_level2,
p_opp_a5 = post_level0*pred_a5_level0 + post_level1*pred_a5_level1 + post_level2*pred_a5_level2
) %>%
mutate(p_self_a1 = case_when(
game == "numbers" ~ (1-beta)*(1/3) + beta*p_opp_a5,
TRUE ~ (1-beta)*(1/3) + beta*(p_opp_a3)
),
p_self_a2 = case_when(
game == "numbers" ~ (1-beta)*(1/3) + beta*p_opp_a1,
TRUE ~ (1-beta)*(1/3) + beta*(p_opp_a1)
),
p_self_a3 = case_when(
game == "numbers" ~ (1-beta)*(1/3) + beta*p_opp_a2,
TRUE ~ (1-beta)*(1/3) + beta*(p_opp_a2)
),
p_self_a4 = case_when(
game == "numbers" ~ (1-beta)*(1/3) + beta*p_opp_a3,
TRUE ~ 0
),
p_self_a5 = case_when(
game == "numbers" ~ (1-beta)*(1/3) + beta*p_opp_a4,
TRUE ~ 0
)
)
# now finally compute the likelihood of human actions
dat <- dat %>%
mutate(
loglik = case_when(
human_action_num == 1 ~ log(p_self_a1),
human_action_num == 2 ~ log(p_self_a2),
human_action_num == 3 ~ log(p_self_a3),
human_action_num == 4 ~ log(p_self_a4),
human_action_num == 5 ~ log(p_self_a5))
)
#cat(as.character(exp(dat$loglik)), "\n", "\n")
ret <- -2*sum(dat$loglik)
if(is.infinite(ret) || is.nan(ret)) {
return(1e+300)
} else {
return(ret)
}
# return(-2*sum(dat$loglik))
}
results_dat <- exp1_Bayes_model_LL(0.4,data = dat, generalize = "game")
exp1_Bayes_model_LL(0.4,data = dat, generalize = "game")
#PLot likelihood for first participant as function of parameter
likelihoods <- list()
for (t in 1:95) {
likelihoods[t] <- exp1_Bayes_model_LL(t/100,data = dat, generalize = "game")
}
jpeg(file="QSuzBXpbyRc370HsAACW.jpeg")
plot(unlist(likelihoods))
dev.off()
library(DEoptim)
exp1_Bayes_game_Tr <- exp1_Bayes_no_Tr <- list()
# # USing DEOptim
for(id in levels(dat$human_id)) {
tdat <- subset(dat,human_id == id)
ctrl <- DEoptim.control(NP = 20, itermax=50, parallelType=1)
exp1_Bayes_game_Tr[[id]] <- DEoptim(exp1_Bayes_model_LL, lower=c(0), upper = c(1), data = tdat,
generalize = "game",control=ctrl)
exp1_Bayes_no_Tr[[id]] <- DEoptim(exp1_Bayes_model_LL, lower=c(0), upper = c(1), data = tdat,
generalize = "no",control=ctrl)
}
library(DEoptim)
exp1_Bayes_game_Tr <- exp1_Bayes_no_Tr <- list()
# # USing DEOptim
for(id in levels(dat$human_id)) {
tdat <- subset(dat,human_id == id)
ctrl <- DEoptim.control(NP = 20, itermax=50)
exp1_Bayes_game_Tr[[id]] <- DEoptim(exp1_Bayes_model_LL, lower=c(0), upper = c(1), data = tdat,
generalize = "game",control=ctrl)
exp1_Bayes_no_Tr[[id]] <- DEoptim(exp1_Bayes_model_LL, lower=c(0), upper = c(1), data = tdat,
generalize = "no",control=ctrl)
}
# ctrl <- DEoptim.control(NP = 20, itermax=50)
# exp1_Bayes_no_Tr[["one"]] <- DEoptim(exp1_Bayes_model_LL, lower=c(0), upper = c(1), data = dat,
#                                   generalize = "no",control=ctrl)
#
# exp1_Bayes_game_Tr [["one"]] <- DEoptim(exp1_Bayes_model_LL, lower=c(0), upper = c(1), data = dat,
#                                    generalize = "game",control=ctrl)
# using optim
# for(id in levels(dat$human_id)) {
#   tdat <- subset(dat,human_id == id)
#   # ctrl <- DEoptim.control(NP = 20, itermax=50)
#
#   Bayes_same_game[[id]] <- optim(c(0.1),fn=Bayes_model_LL,data=tdat, distinct_opponent = FALSE,
#                                  generalize = "game", lower = c(0), upper = c(1),method="L-BFGS-B")
#
#
#   Bayes_same_stage[[id]] <- optim(c(0.1),fn=Bayes_model_LL,data=tdat, distinct_opponent = FALSE,
#                                  generalize = "stage", lower = c(0), upper = c(1),method="L-BFGS-B")
#
#   Bayes_same_no[[id]] <- optim(c(0.1),fn=Bayes_model_LL,data=tdat, distinct_opponent = FALSE,
#                                  generalize = "no", lower = c(0), upper = c(1),method="L-BFGS-B")
#
#   Bayes_distinct_game[[id]] <- optim(c(0.1),fn=Bayes_model_LL,data=tdat, distinct_opponent = TRUE,
#                                  generalize = "game", lower = c(0), upper = c(1),method="L-BFGS-B")
#
#   Bayes_distinct_stage[[id]] <- optim(c(0.1),fn=Bayes_model_LL,data=tdat, distinct_opponent = TRUE,
#                                  generalize = "stage", lower = c(0), upper = c(1),method="L-BFGS-B")
#
#   Bayes_distinct_no[[id]] <- optim(c(0.1),fn=Bayes_model_LL,data=tdat, distinct_opponent = TRUE,
#                                  generalize = "no", lower = c(0), upper = c(1),method="L-BFGS-B")
# }
