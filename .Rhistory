cor.test(Corr_Tr_model$BIC_diff_rand, Corr_Tr_model$Early_game_score, method=c("pearson", "kendall", "spearman"))
## Correlate difference between BICs of Bayes transfer and no transfer with early rounds score (evidence for transfer)
Corr_Tr_model <- data.frame()
for(id in unique(dat$human_id)) {
tdat <- subset(dat,human_id == id)
tot_score <- sum(tdat$score)
early_dat <- subset(tdat,between(tdat$round,2,5) & (game =="fwg" | game =="numbers") )
tr_score <- sum(early_dat$score)
id_results <- subset(All_results, ID == id)
min_BIC <- apply(id_results[,c("Random_BIC","Bayes_Tr_BIC","Bayes_No_Tr_BIC","QL_BIC","QL_states_BIC","EWA_BIC","EWA_self_BIC")],1,min)
best_model <- c("random","Bayes Tr","Bayes No Tr","QL", "QL_states","EWA","S_EWA")[apply(id_results[,c("Random_BIC","Bayes_Tr_BIC","Bayes_No_Tr_BIC","QL_BIC","QL_states_BIC","EWA_BIC","EWA_self_BIC")],1,which.min)]
#
Corr_Tr_model <- rbind(Corr_Tr_model ,
data.frame(
"id" = id,
"condition" = dat[dat$human_id==id,"condition"][1],
"BIC_diff_Bayes" = id_results[,"Bayes_Tr_BIC"] - id_results[,"Bayes_No_Tr_BIC"],
"BIC_diff_rand" =  id_results[,"Random_BIC"] - min_BIC,
"Early_game_score" = tr_score,
"Total_Score" = tot_score,
"best_model" = best_model
))
}
# Correlate difference between BICs of Bayes transfer and no transfer with early rounds score (evidence for transfer)
cor.test(Corr_Tr_model$BIC_diff_Bayes,Corr_Tr_model$Early_game_score, method=c("pearson", "kendall", "spearman"))
# Correlation between early game score and difference between best model and random BIC
cor.test(Corr_Tr_model$BIC_diff_rand, Corr_Tr_model$Early_game_score, method=c("pearson", "kendall", "spearman"))
Q_learn_states <- function(par,data,return_value){
# beta= inverse temperature parameter in softmax choice function
# lambda = learning rate (one per game?)
# data : participant and ai choice data.
# return_value=c("-2loglik","likelihood_by_trial")
# Returns Q-values per trial and predicts choice using softmax
beta <- par[1]
alpha <- par[2]
#fix discount factor at 0.9
gamma <- 0.9
#Define matrix of state spaces for each game
G1 <- expand.grid(c("R", "P", "S"),c("R", "P", "S"))
states_RPS <- paste0(G1$Var1,G1$Var2)
G2 <- expand.grid(c("F", "W", "G"), c("F", "W", "G"))
states_FWG <- paste0(G2$Var1,G2$Var2)
G3 <- expand.grid(c("1", "2", "3", "4", "5"), c("1", "2", "3", "4", "5"))
states_NUM <- paste0(G3$Var1,G3$Var2)
Q_vals_RPS = matrix(0.0,9,3)
dimnames(Q_vals_RPS) = list(states_RPS, c("R", "P", "S"))
Q_vals_FWG = matrix(0.0,9,3)
dimnames(Q_vals_FWG) = list(states_FWG, c("F", "W", "G"))
Q_vals_NUM = matrix(0.0,25,5)
dimnames(Q_vals_NUM) = list(states_NUM, c("1", "2", "3", "4", "5"))
lik_hum <- matrix(0.0,nrow(data))
for(t in 1:nrow(data)) {
t_game <- data[t,"game"]
if(t_game == "numbers") nopts <- 5 else nopts <- 3
if(data[t,"round"] == 1) {
# first round is uniform prediction
Q_vals <- switch(as.character(t_game),rps=Q_vals_RPS,fwg = Q_vals_FWG, numbers = Q_vals_NUM)
state_vec <- switch(as.character(t_game),rps=states_RPS,fwg = states_FWG, numbers = states_NUM)
lik_hum[t] <- 1/nopts
# Randomly select prev_state and actions for first round
state_prev  <- sample(state_vec, size = 1)
h_act_prev <- sample(colnames(Q_vals), size =1)
a_act_prev <- sample(colnames(Q_vals), size =1)
reward <- 0
} else {
# Get reward and past human action
reward <- as.numeric(data[t-1,"score"])
h_act_prev <- as.character(data[t-1,"h_action"])
a_act_prev <- as.character(data[t-1,"a_action"])
}
# cat(state_prev, " This is the previous state", "\n")
new_state <- paste0(h_act_prev,a_act_prev)
# cat(new_state,"This is new state","\n")
# Q_learning: update rule
Q_vals[state_prev, a_act_prev] <- Q_vals[state_prev, a_act_prev] + alpha*( reward + gamma*max(Q_vals[new_state,])- Q_vals[state_prev, a_act_prev])
# Assume human chooses action probabilistically using softmax on Q values
probs <- exp(Q_vals[new_state,]/beta)/sum(exp(Q_vals[new_state,]/beta))
#cat(Q_vals,"\n")
# Get actual human action and compute likelihood
h_act <- as.character(data[t,"h_action"])
act_index <- match(h_act, colnames(Q_vals))
lik_hum[t] <- probs[[act_index]]
# Update state
state_prev <- new_state
#}
}
if(return_value == "-2loglik") {
ret <- -2*sum(log(lik_hum))
if(is.infinite(ret) || is.nan(ret)) {
return(1e+300)
} else {
return(ret)
}
}
if(return_value == "likelihood_by_trial") return(lik_hum)
}
data = subset(dat,human_id == "38VxtUSv_h6RR5-tAAA2")
Q_learn_states(c(0.1,0.1), data, "-2loglik")
# QL_states_modelling <- list()
# for(id in unique(dat$human_id)) {
#   QL_states_modelling[[id]] <- list()
#   tdat <- subset(dat,human_id == id)
#   QL_states_modelling[[id]] <- optim(c(1,0.1),fn=Q_learn_states,gr = NULL, data=tdat,"-2loglik", lower = c(0,0), upper = c(10,0.99), method="L-BFGS-B")
# }
#
# save(QL_states_modelling,file="QL_states_modelling.RData")
Q_learn_states <- function(par,data,return_value){
# beta= inverse temperature parameter in softmax choice function
# lambda = learning rate (one per game?)
# data : participant and ai choice data.
# return_value=c("-2loglik","likelihood_by_trial")
# Returns Q-values per trial and predicts choice using softmax
beta <- par[1]
alpha <- par[2]
#fix discount factor at 0.9
gamma <- 0.9
#Define matrix of state spaces for each game
G1 <- expand.grid(c("R", "P", "S"),c("R", "P", "S"))
states_RPS <- paste0(G1$Var1,G1$Var2)
G2 <- expand.grid(c("F", "W", "G"), c("F", "W", "G"))
states_FWG <- paste0(G2$Var1,G2$Var2)
G3 <- expand.grid(c("1", "2", "3", "4", "5"), c("1", "2", "3", "4", "5"))
states_NUM <- paste0(G3$Var1,G3$Var2)
Q_vals_RPS = matrix(0.0,9,3)
dimnames(Q_vals_RPS) = list(states_RPS, c("R", "P", "S"))
Q_vals_FWG = matrix(0.0,9,3)
dimnames(Q_vals_FWG) = list(states_FWG, c("F", "W", "G"))
Q_vals_NUM = matrix(0.0,25,5)
dimnames(Q_vals_NUM) = list(states_NUM, c("1", "2", "3", "4", "5"))
lik_hum <- matrix(0.0,nrow(data))
for(t in 1:nrow(data)) {
t_game <- data[t,"game"]
if(t_game == "numbers") nopts <- 5 else nopts <- 3
if(data[t,"round"] == 1) {
# first round is uniform prediction
Q_vals <- switch(as.character(t_game),rps=Q_vals_RPS,fwg = Q_vals_FWG, numbers = Q_vals_NUM)
state_vec <- switch(as.character(t_game),rps=states_RPS,fwg = states_FWG, numbers = states_NUM)
lik_hum[t] <- 1/nopts
# Randomly select prev_state and actions for first round
state_prev  <- sample(state_vec, size = 1)
h_act_prev <- sample(colnames(Q_vals), size =1)
a_act_prev <- sample(colnames(Q_vals), size =1)
reward <- 0
} else {
# Get reward and past human action
reward <- as.numeric(data[t-1,"score"])
h_act_prev <- as.character(data[t-1,"h_action"])
a_act_prev <- as.character(data[t-1,"a_action"])
}
# cat(state_prev, " This is the previous state", "\n")
new_state <- paste0(h_act_prev,a_act_prev)
# cat(new_state,"This is new state","\n")
# Q_learning: update rule
Q_vals[state_prev, a_act_prev] <- Q_vals[state_prev, a_act_prev] + alpha*( reward + gamma*max(Q_vals[new_state,])- Q_vals[state_prev, a_act_prev])
# Assume human chooses action probabilistically using softmax on Q values
probs <- exp(Q_vals[new_state,]/beta)/sum(exp(Q_vals[new_state,]/beta))
cat(Q_vals,"\n")
# Get actual human action and compute likelihood
h_act <- as.character(data[t,"h_action"])
act_index <- match(h_act, colnames(Q_vals))
lik_hum[t] <- probs[[act_index]]
# Update state
state_prev <- new_state
#}
}
if(return_value == "-2loglik") {
ret <- -2*sum(log(lik_hum))
if(is.infinite(ret) || is.nan(ret)) {
return(1e+300)
} else {
return(ret)
}
}
if(return_value == "likelihood_by_trial") return(lik_hum)
}
data = subset(dat,human_id == "38VxtUSv_h6RR5-tAAA2")
Q_learn_states(c(0.1,0.1), data, "-2loglik")
# QL_states_modelling <- list()
# for(id in unique(dat$human_id)) {
#   QL_states_modelling[[id]] <- list()
#   tdat <- subset(dat,human_id == id)
#   QL_states_modelling[[id]] <- optim(c(1,0.1),fn=Q_learn_states,gr = NULL, data=tdat,"-2loglik", lower = c(0,0), upper = c(10,0.99), method="L-BFGS-B")
# }
#
# save(QL_states_modelling,file="QL_states_modelling.RData")
Q_learn_states <- function(par,data,return_value){
# beta= inverse temperature parameter in softmax choice function
# lambda = learning rate (one per game?)
# data : participant and ai choice data.
# return_value=c("-2loglik","likelihood_by_trial")
# Returns Q-values per trial and predicts choice using softmax
beta <- par[1]
alpha <- par[2]
#fix discount factor at 0.9
gamma <- 0.9
#Define matrix of state spaces for each game
G1 <- expand.grid(c("R", "P", "S"),c("R", "P", "S"))
states_RPS <- paste0(G1$Var1,G1$Var2)
G2 <- expand.grid(c("F", "W", "G"), c("F", "W", "G"))
states_FWG <- paste0(G2$Var1,G2$Var2)
G3 <- expand.grid(c("1", "2", "3", "4", "5"), c("1", "2", "3", "4", "5"))
states_NUM <- paste0(G3$Var1,G3$Var2)
Q_vals_RPS = matrix(0.0,9,3)
dimnames(Q_vals_RPS) = list(states_RPS, c("R", "P", "S"))
Q_vals_FWG = matrix(0.0,9,3)
dimnames(Q_vals_FWG) = list(states_FWG, c("F", "W", "G"))
Q_vals_NUM = matrix(0.0,25,5)
dimnames(Q_vals_NUM) = list(states_NUM, c("1", "2", "3", "4", "5"))
lik_hum <- matrix(0.0,nrow(data))
for(t in 1:nrow(data)) {
t_game <- data[t,"game"]
if(t_game == "numbers") nopts <- 5 else nopts <- 3
if(data[t,"round"] == 1) {
# first round is uniform prediction
Q_vals <- switch(as.character(t_game),rps=Q_vals_RPS,fwg = Q_vals_FWG, numbers = Q_vals_NUM)
state_vec <- switch(as.character(t_game),rps=states_RPS,fwg = states_FWG, numbers = states_NUM)
lik_hum[t] <- 1/nopts
# Randomly select prev_state and actions for first round
state_prev  <- sample(state_vec, size = 1)
h_act_prev <- sample(colnames(Q_vals), size =1)
a_act_prev <- sample(colnames(Q_vals), size =1)
reward <- 0
} else {
# Get reward and past human action
reward <- as.numeric(data[t-1,"score"])
h_act_prev <- as.character(data[t-1,"h_action"])
a_act_prev <- as.character(data[t-1,"a_action"])
}
# cat(state_prev, " This is the previous state", "\n")
new_state <- paste0(h_act_prev,a_act_prev)
# cat(new_state,"This is new state","\n")
# Q_learning: update rule
Q_vals[state_prev, a_act_prev] <- Q_vals[state_prev, a_act_prev] + alpha*( reward + gamma*max(Q_vals[new_state,])- Q_vals[state_prev, a_act_prev])
# Assume human chooses action probabilistically using softmax on Q values
probs <- exp(Q_vals[new_state,]/beta)/sum(exp(Q_vals[new_state,]/beta))
if (data[t,"round"] == 50) { cat(Q_vals,"\n") }
# Get actual human action and compute likelihood
h_act <- as.character(data[t,"h_action"])
act_index <- match(h_act, colnames(Q_vals))
lik_hum[t] <- probs[[act_index]]
# Update state
state_prev <- new_state
#}
}
if(return_value == "-2loglik") {
ret <- -2*sum(log(lik_hum))
if(is.infinite(ret) || is.nan(ret)) {
return(1e+300)
} else {
return(ret)
}
}
if(return_value == "likelihood_by_trial") return(lik_hum)
}
data = subset(dat,human_id == "38VxtUSv_h6RR5-tAAA2")
Q_learn_states(c(0.1,0.1), data, "-2loglik")
# QL_states_modelling <- list()
# for(id in unique(dat$human_id)) {
#   QL_states_modelling[[id]] <- list()
#   tdat <- subset(dat,human_id == id)
#   QL_states_modelling[[id]] <- optim(c(1,0.1),fn=Q_learn_states,gr = NULL, data=tdat,"-2loglik", lower = c(0,0), upper = c(10,0.99), method="L-BFGS-B")
# }
#
# save(QL_states_modelling,file="QL_states_modelling.RData")
## Correlate difference between BICs of Bayes transfer and no transfer with early rounds score (evidence for transfer)
Corr_Tr_model <- data.frame()
for(id in unique(dat$human_id)) {
tdat <- subset(dat,human_id == id)
tot_score <- sum(tdat$score)
early_dat <- subset(tdat,between(tdat$round,2,5) & (game =="fwg" | game =="numbers") )
tr_score <- sum(early_dat$score)
id_results <- subset(All_results, ID == id)
min_BIC <- apply(id_results[,c("Random_BIC","Bayes_Tr_BIC","Bayes_No_Tr_BIC","QL_BIC","QL_states_BIC","EWA_BIC","EWA_self_BIC")],1,min)
best_model <- c("random","Bayes Tr","Bayes No Tr","QL", "QL_states","EWA","S_EWA")[apply(id_results[,c("Random_BIC","Bayes_Tr_BIC","Bayes_No_Tr_BIC","QL_BIC","QL_states_BIC","EWA_BIC","EWA_self_BIC")],1,which.min)]
#
Corr_Tr_model <- rbind(Corr_Tr_model ,
data.frame(
"id" = id,
"condition" = dat[dat$human_id==id,"condition"][1],
"BIC_diff_Bayes" = id_results[,"Bayes_Tr_BIC"] - id_results[,"Bayes_No_Tr_BIC"],
"BIC_diff_rand" =  id_results[,"Random_BIC"] - min_BIC,
"Early_game_score" = tr_score,
"Total_score" = tot_score,
"Best_model" = best_model
))
}
# Correlate difference between BICs of Bayes transfer and no transfer with early rounds score (evidence for transfer)
cor.test(Corr_Tr_model$BIC_diff_Bayes,Corr_Tr_model$Early_game_score, method=c("pearson", "kendall", "spearman"))
# Correlation between early game score and difference between best model and random BIC
cor.test(Corr_Tr_model$BIC_diff_rand, Corr_Tr_model$Early_game_score, method=c("pearson", "kendall", "spearman"))
Corr_Tr_model$model <- recode(Corr_Tr_model$Best_model,"Bayes Tr" = "Tranfer","Bayes No Tr" = "No Transfer", .default = "Random")
levels(Corr_Tr_model$Best_model)
library("ggpubr")
install.packages("ggpubr")
## Correlate difference between BICs of Bayes transfer and no transfer with early rounds score (evidence for transfer)
Corr_Tr_model <- data.frame()
for(id in unique(dat$human_id)) {
tdat <- subset(dat,human_id == id)
tot_score <- sum(tdat$score)
early_dat <- subset(tdat,between(tdat$round,2,5) & (game =="fwg" | game =="numbers") )
tr_score <- sum(early_dat$score)
id_results <- subset(All_results, ID == id)
min_BIC <- apply(id_results[,c("Random_BIC","Bayes_Tr_BIC","Bayes_No_Tr_BIC","QL_BIC","QL_states_BIC","EWA_BIC","EWA_self_BIC")],1,min)
best_model <- c("random","Bayes Tr","Bayes No Tr","QL", "QL_states","EWA","S_EWA")[apply(id_results[,c("Random_BIC","Bayes_Tr_BIC","Bayes_No_Tr_BIC","QL_BIC","QL_states_BIC","EWA_BIC","EWA_self_BIC")],1,which.min)]
#
Corr_Tr_model <- rbind(Corr_Tr_model ,
data.frame(
"id" = id,
"condition" = dat[dat$human_id==id,"condition"][1],
"BIC_diff_Bayes" = id_results[,"Bayes_Tr_BIC"] - id_results[,"Bayes_No_Tr_BIC"],
"BIC_diff_rand" =  id_results[,"Random_BIC"] - min_BIC,
"Early_game_score" = tr_score,
"Total_score" = tot_score,
"Best_model" = best_model
))
}
# Correlate difference between BICs of Bayes transfer and no transfer with early rounds score (evidence for transfer)
cor.test(Corr_Tr_model$BIC_diff_Bayes,Corr_Tr_model$Early_game_score, method=c("pearson", "kendall", "spearman"))
# Correlation between early game score and difference between best model and random BIC
cor.test(Corr_Tr_model$BIC_diff_rand, Corr_Tr_model$Early_game_score, method=c("pearson", "kendall", "spearman"))
Corr_Tr_model$model <- recode(Corr_Tr_model$Best_model,"Bayes Tr" = "Tranfer","Bayes No Tr" = "No Transfer", .default = "Random")
levels(Corr_Tr_model$Best_model)
library("ggpubr")
# using some functions from the 'tidyverse' (also for me to get use to them ;-)
library(tidyr)
library(dplyr)
library(DEoptim)
library(ggpubr)
install.packages("ggpubr")
## Correlate difference between BICs of Bayes transfer and no transfer with early rounds score (evidence for transfer)
Corr_Tr_model <- data.frame()
for(id in unique(dat$human_id)) {
tdat <- subset(dat,human_id == id)
tot_score <- sum(tdat$score)
early_dat <- subset(tdat,between(tdat$round,2,5) & (game =="fwg" | game =="numbers") )
tr_score <- sum(early_dat$score)
id_results <- subset(All_results, ID == id)
min_BIC <- apply(id_results[,c("Random_BIC","Bayes_Tr_BIC","Bayes_No_Tr_BIC","QL_BIC","QL_states_BIC","EWA_BIC","EWA_self_BIC")],1,min)
best_model <- c("random","Bayes Tr","Bayes No Tr","QL", "QL_states","EWA","S_EWA")[apply(id_results[,c("Random_BIC","Bayes_Tr_BIC","Bayes_No_Tr_BIC","QL_BIC","QL_states_BIC","EWA_BIC","EWA_self_BIC")],1,which.min)]
#
Corr_Tr_model <- rbind(Corr_Tr_model ,
data.frame(
"id" = id,
"condition" = dat[dat$human_id==id,"condition"][1],
"BIC_diff_Bayes" = id_results[,"Bayes_Tr_BIC"] - id_results[,"Bayes_No_Tr_BIC"],
"BIC_diff_rand" =  id_results[,"Random_BIC"] - min_BIC,
"Early_game_score" = tr_score,
"Total_score" = tot_score,
"Best_model" = best_model
))
}
# Correlate difference between BICs of Bayes transfer and no transfer with early rounds score (evidence for transfer)
cor.test(Corr_Tr_model$BIC_diff_Bayes,Corr_Tr_model$Early_game_score, method=c("pearson", "kendall", "spearman"))
# Correlation between early game score and difference between best model and random BIC
cor.test(Corr_Tr_model$BIC_diff_rand, Corr_Tr_model$Early_game_score, method=c("pearson", "kendall", "spearman"))
Corr_Tr_model$model <- recode(Corr_Tr_model$Best_model,"Bayes Tr" = "Tranfer","Bayes No Tr" = "No Transfer", .default = "Random")
levels(Corr_Tr_model$Best_model)
#
# ggboxplot(Corr_Tr_model, x = "model", y = "Total_score",
#           color = "model", palette = c("#00AFBB", "#E7B800", "#FC4E07"),
#           order = c("Random", "No Transfer", "Transfer"),
#           ylab = "Total Score", xlab = "Model with best fit")
# Compute the analysis of variance
res.aov <- aov(Total_score ~ model, data = Corr_Tr_model)
# Summary of the analysis
summary(res.aov)
## Correlate difference between BICs of Bayes transfer and no transfer with early rounds score (evidence for transfer)
Corr_Tr_model <- data.frame()
for(id in unique(dat$human_id)) {
tdat <- subset(dat,human_id == id)
tot_score <- sum(tdat$score)
early_dat <- subset(tdat,between(tdat$round,2,5) & (game =="fwg" | game =="numbers") )
tr_score <- sum(early_dat$score)
id_results <- subset(All_results, ID == id)
min_BIC <- apply(id_results[,c("Random_BIC","Bayes_Tr_BIC","Bayes_No_Tr_BIC","QL_BIC","QL_states_BIC","EWA_BIC","EWA_self_BIC")],1,min)
best_model <- c("random","Bayes Tr","Bayes No Tr","QL", "QL_states","EWA","S_EWA")[apply(id_results[,c("Random_BIC","Bayes_Tr_BIC","Bayes_No_Tr_BIC","QL_BIC","QL_states_BIC","EWA_BIC","EWA_self_BIC")],1,which.min)]
#
Corr_Tr_model <- rbind(Corr_Tr_model ,
data.frame(
"id" = id,
"condition" = dat[dat$human_id==id,"condition"][1],
"BIC_diff_Bayes" = id_results[,"Bayes_Tr_BIC"] - id_results[,"Bayes_No_Tr_BIC"],
"BIC_diff_rand" =  id_results[,"Random_BIC"] - min_BIC,
"Early_game_score" = tr_score,
"Total_score" = tot_score,
"Best_model" = best_model
))
}
# Correlate difference between BICs of Bayes transfer and no transfer with early rounds score (evidence for transfer)
cor.test(Corr_Tr_model$BIC_diff_Bayes,Corr_Tr_model$Early_game_score, method=c("pearson", "kendall", "spearman"))
# Correlation between early game score and difference between best model and random BIC
cor.test(Corr_Tr_model$BIC_diff_rand, Corr_Tr_model$Early_game_score, method=c("pearson", "kendall", "spearman"))
Corr_Tr_model$model <- recode(Corr_Tr_model$Best_model,"Bayes Tr" = "Tranfer","Bayes No Tr" = "No Transfer", .default = "Random")
levels(Corr_Tr_model$Best_model)
#
# ggboxplot(Corr_Tr_model, x = "model", y = "Total_score",
#           color = "model", palette = c("#00AFBB", "#E7B800", "#FC4E07"),
#           order = c("Random", "No Transfer", "Transfer"),
#           ylab = "Total Score", xlab = "Model with best fit")
# Compute the analysis of variance
res.aov <- aov(Total_score ~ model, data = Corr_Tr_model)
# Summary of the analysis
summary(res.aov)
pairwise.t.test(Total_score, model, p.adj = "holm")
# ggboxplot(Corr_Tr_model, x = "model", y = "Total_score",
#           color = "model", palette = c("#00AFBB", "#E7B800", "#FC4E07"),
#           order = c("Random", "No Transfer", "Transfer"),
#           ylab = "Total Score", xlab = "Model with best fit")
tapply(Total_score, model, mean)
# ggboxplot(Corr_Tr_model, x = "model", y = "Total_score",
#           color = "model", palette = c("#00AFBB", "#E7B800", "#FC4E07"),
#           order = c("Random", "No Transfer", "Transfer"),
#           ylab = "Total Score", xlab = "Model with best fit")
Corr_Tr_model$model <- recode(Corr_Tr_model$Best_model,"Bayes Tr" = "Tranfer","Bayes No Tr" = "No Transfer", .default = "Random")
levels(Corr_Tr_model$model)
tapply(Total_score, model, mean)
# ggboxplot(Corr_Tr_model, x = "model", y = "Total_score",
#           color = "model", palette = c("#00AFBB", "#E7B800", "#FC4E07"),
#           order = c("Random", "No Transfer", "Transfer"),
#           ylab = "Total Score", xlab = "Model with best fit")
Corr_Tr_model$model <- recode(Corr_Tr_model$Best_model,"Bayes Tr" = "Tranfer","Bayes No Tr" = "No Transfer", .default = "Random")
model <- factor(Corr_Tr_model$model)
tapply(Total_score, model, mean)
# ggboxplot(Corr_Tr_model, x = "model", y = "Total_score",
#           color = "model", palette = c("#00AFBB", "#E7B800", "#FC4E07"),
#           order = c("Random", "No Transfer", "Transfer"),
#           ylab = "Total Score", xlab = "Model with best fit")
Corr_Tr_model$model <- recode(Corr_Tr_model$Best_model,"Bayes Tr" = "Tranfer","Bayes No Tr" = "No Transfer", .default = "Random")
model <- factor(Corr_Tr_model$model)
tapply(Corr_Tr_model$Total_score, model, mean)
# Compute the analysis of variance
res.aov <- aov(Total_score ~ model, data = Corr_Tr_model)
# Summary of the analysis
summary(res.aov)
pairwise.t.test(Total_score, model, p.adj = "holm")
# ggboxplot(Corr_Tr_model, x = "model", y = "Total_score",
#           color = "model", palette = c("#00AFBB", "#E7B800", "#FC4E07"),
#           order = c("Random", "No Transfer", "Transfer"),
#           ylab = "Total Score", xlab = "Model with best fit")
Corr_Tr_model$model <- recode(Corr_Tr_model$Best_model,"Bayes Tr" = "Tranfer","Bayes No Tr" = "No Transfer", .default = "Random")
model <- factor(Corr_Tr_model$model)
tapply(Corr_Tr_model$Total_score, model, mean)
# Compute the analysis of variance
res.aov <- aov(Total_score ~ model, data = Corr_Tr_model)
# Summary of the analysis
summary(res.aov)
pairwise.t.test(Corr_Tr_model$Total_score, model, p.adj = "holm")
# ggboxplot(Corr_Tr_model, x = "model", y = "Total_score",
#           color = "model", palette = c("#00AFBB", "#E7B800", "#FC4E07"),
#           order = c("Random", "No Transfer", "Transfer"),
#           ylab = "Total Score", xlab = "Model with best fit")
Corr_Tr_model$model <- recode(Corr_Tr_model$Best_model,"Bayes Tr" = "Tranfer","Bayes No Tr" = "No Transfer", .default = "Random")
model <- factor(Corr_Tr_model$model)
tapply(Corr_Tr_model$Total_score, model, mean)
# Compute the analysis of variance
res.aov <- aov(Total_score ~ model, data = Corr_Tr_model)
# Summary of the analysis
summary(res.aov)
pairwise.t.test(Corr_Tr_model$Total_score, model, p.adj = "None")
# ggboxplot(Corr_Tr_model, x = "model", y = "Total_score",
#           color = "model", palette = c("#00AFBB", "#E7B800", "#FC4E07"),
#           order = c("Random", "No Transfer", "Transfer"),
#           ylab = "Total Score", xlab = "Model with best fit")
Corr_Tr_model$model <- recode(Corr_Tr_model$Best_model,"Bayes Tr" = "Tranfer","Bayes No Tr" = "No Transfer", .default = "Random")
model <- factor(Corr_Tr_model$model)
tapply(Corr_Tr_model$Total_score, model, mean)
# Compute the analysis of variance
res.aov <- aov(Total_score ~ model, data = Corr_Tr_model)
# Summary of the analysis
summary(res.aov)
pairwise.t.test(Corr_Tr_model$Total_score, model, p.adj = "none")
# ggboxplot(Corr_Tr_model, x = "model", y = "Total_score",
#           color = "model", palette = c("#00AFBB", "#E7B800", "#FC4E07"),
#           order = c("Random", "No Transfer", "Transfer"),
#           ylab = "Total Score", xlab = "Model with best fit")
Corr_Tr_model$model <- recode(Corr_Tr_model$Best_model,"Bayes Tr" = "Tranfer","Bayes No Tr" = "No Transfer", .default = "Random")
model <- factor(Corr_Tr_model$model)
tapply(Corr_Tr_model$Total_score, model, mean)
# Compute the analysis of variance
res.aov <- aov(Total_score ~ model, data = Corr_Tr_model)
# Summary of the analysis
summary(res.aov)
pairwise.t.test(Corr_Tr_model$Total_score, model, p.adj = "bonf")
# ggboxplot(Corr_Tr_model, x = "model", y = "Total_score",
#           color = "model", palette = c("#00AFBB", "#E7B800", "#FC4E07"),
#           order = c("Random", "No Transfer", "Transfer"),
#           ylab = "Total Score", xlab = "Model with best fit")
Corr_Tr_model$model <- recode(Corr_Tr_model$Best_model,"Bayes Tr" = "Tranfer","Bayes No Tr" = "No Transfer", .default = "Random")
model <- factor(Corr_Tr_model$model)
tapply(Corr_Tr_model$Total_score, model, mean)
# Compute the analysis of variance
res.aov <- aov(Total_score ~ model, data = Corr_Tr_model)
# Summary of the analysis
summary(res.aov)
pairwise.t.test(Corr_Tr_model$Total_score, model, p.adj = "holm")
# using some functions from the 'tidyverse' (also for me to get use to them ;-)
library(tidyr)
library(dplyr)
library(DEoptim)
# library(ggpubr)
# transform 'winner' variable in numeric score
dat$score <- recode(dat$winner, human = 1, tie = 0, ai = -1)
# create a new variable 'block' with round 1...25 = block 1 and round 26...50 as block 2
dat$block <- as.numeric(cut(dat$round,2))
# create a new data.frame in a 'wide format'
# widedata <- dat %>%
#   unite(game_block,game,block) %>% # this creates a new variable which combines game and block
#     group_by(human_id,condition,game_block) %>% # let the functions know you want to separate things by ID, condition, and game_block
#       summarize(mean_score = mean(score)) %>% # compute average score (i.e wins - losses)
#         spread(game_block,mean_score) # reformat in the 'wide' format
# # save the data file as a .csv to use in e.g. SPSS
# write.csv(widedata,row.names=FALSE,file="scores_wide.csv")
