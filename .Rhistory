#
# # create a new variable "game.f" as a factor variable of games
# dat_exp2$game.f <- factor(dat_exp2$game, labels = c("RPS","FWG","SHOOT"),levels=c("rps","fwg","shootout"))
#
# # recode actions to make them equal to the codes in these files
# dat_exp2$h_action <- recode(dat_exp2$human_action,"rock" = "R", "paper" = "P", "scissors" = "S", "fire" = "F", "water" = "W", "grass" = "G")
# dat_exp2$a_action <- recode(dat_exp2$ai_action,"rock" = "R", "paper" = "P", "scissors" = "S", "fire" = "F", "water" = "W", "grass" = "G")
#
# write.csv(dat_exp2, row.names=FALSE,file="data_exp2.csv")
# Load various modelling tables
load("exp2_TR_bayes.RData")
load("exp2_NT_bayes.RData")
load("exp2_QLS_modelling.RData")
load("exp2_SEWA_modelling.RData")
load("MBM2_modelling.RData")
exp2_results <- data.frame()
for(id in unique(dat_exp2$human_id)) {
exp2_results <- rbind(exp2_results,
data.frame(
"ID" = id,
"condition" = dat_exp2[dat_exp2$human_id==id,"condition"][1],
"Random_BIC" = -2*(180*log(1/3)),
# Bayesian updating with/without transfer
"Bayes_Tr_BIC" = exp2_TR_bayes[[id]]$value + 2*log(180),
"Bayes_No_Tr_BIC" = exp2_NT_bayes[[id]]$value+ 2*log(180),
# Theta is the parameter governing AI stochasticity. Truth is 0.9
"theta_transfer" = exp2_TR_bayes[[id]]$par[1],
"theta_no_transfer" = exp2_NT_bayes[[id]]$par[1],
# Epsilone is parameter showing cases where human deviates from predictions about opponent (lower better)
"eps_transfer" = exp2_TR_bayes[[id]]$par[2],
"eps_no_transfer" = exp2_NT_bayes[[id]]$par[2],
# Q-learning with last round states
"QL_states_BIC" = exp2_QLS_modelling[[id]]$optim$bestval + 2*log(180),
# beta ->  inverse temperature parameter in softmax choice function
"QL_states_Beta" = exp2_QLS_modelling[[id]]$optim$bestmem[1],
# alpha -> learning rate in QL update
"QL_states_alpha" = exp2_QLS_modelling[[id]]$optim$bestmem[2],
# Self-Tuning EWA (only 1 parameter)
# BIC
"EWA_self_2LL" = exp2_SEWA_modelling[[id]]$optim$bestval,
"EWA_self_BIC" = exp2_SEWA_modelling[[id]]$optim$bestval + 1*log(180),
#Lambda is a parameter of the softmax choice function (inverse Temperature)
"EWA_self_Lambda" = exp2_SEWA_modelling[[id]]$optim$bestmem[1],
# Model Based Model
# BIC
"MBM_2LL" = MBM2_modelling[[id]]$optim$bestval,
"MBM2_BIC" = MBM2_modelling[[id]]$optim$bestval + 2*log(180),
# Alpha is learning rate, beta is temperature in softmax
"MBM2_alpha" = MBM2_modelling[[id]]$optim$bestmem[1],
"MBM2_beta" = MBM2_modelling[[id]]$optim$bestmem[2]
))
}
write.csv(exp2_results,file="exp2_results.csv",row.names = FALSE)
exp2_table_results <- table(exp2_results[, "condition"],c("random","Bayes Tr","Bayes No Tr", "QL_states","S_EWA","MBM")[apply(exp2_results[,c("Random_BIC","Bayes_Tr_BIC","Bayes_No_Tr_BIC","QL_states_BIC","EWA_self_BIC","MBM2_BIC")],1,which.min)])
write.csv(exp2_table_results,file="exp2_table_results.csv",row.names = TRUE)
kable(exp2_table_results)
knitr::opts_chunk$set(echo = TRUE)
library(tidyr)
library(dplyr)
library(DEoptim)
library(optimParallel)
library(ggpubr)
# dat_exp2 <- read.csv("MyData.csv")
#
# # transform 'winner' variable in numeric score
# dat_exp2$score <- recode(dat_exp2$winner, human = 1, tie = 0, AI = -1)
#
# # Create a new variable stage.f as a factor for the stages 1,2 ,3 4 in game
# dat_exp2$stage.f <- factor(dat_exp2$stage, labels = c("Stage 1","Stage 2","Stage 3", "Stage 4"),levels=c(1,2,3,4))
#
# # create a new variable "game.f" as a factor variable of games
# dat_exp2$game.f <- factor(dat_exp2$game, labels = c("RPS","FWG","SHOOT"),levels=c("rps","fwg","shootout"))
#
# # recode actions to make them equal to the codes in these files
# dat_exp2$h_action <- recode(dat_exp2$human_action,"rock" = "R", "paper" = "P", "scissors" = "S", "fire" = "F", "water" = "W", "grass" = "G")
# dat_exp2$a_action <- recode(dat_exp2$ai_action,"rock" = "R", "paper" = "P", "scissors" = "S", "fire" = "F", "water" = "W", "grass" = "G")
#
# write.csv(dat_exp2, row.names=FALSE,file="data_exp2.csv")
# Read in cleaned data file
dat_exp2 <- read.csv("data_exp2.csv")
test_data = subset(dat_exp2,human_id == "bZg1T3MNoItL6b7qAAAj")
exp2_table_results <- table(exp2_results[, "condition"],c("random","Bayes Tr","Bayes No Tr", "QL_states","S_EWA","MBM")[apply(exp2_results[,c("Random_BIC","Bayes_Tr_BIC","Bayes_No_Tr_BIC","QL_states_BIC","EWA_self_BIC","MBM2_BIC")],1,which.min)])
write.csv(exp2_table_results,file="exp2_table_results.csv",row.names = TRUE)
kable(exp2_table_results)
library(knitr)
knitr::opts_chunk$set(echo = TRUE)
exp2_table_results <- table(exp2_results[, "condition"],c("random","Bayes Tr","Bayes No Tr", "QL_states","S_EWA","MBM")[apply(exp2_results[,c("Random_BIC","Bayes_Tr_BIC","Bayes_No_Tr_BIC","QL_states_BIC","EWA_self_BIC","MBM2_BIC")],1,which.min)])
write.csv(exp2_table_results,file="exp2_table_results.csv",row.names = TRUE)
kable(exp2_table_results)
View(exp2_results)
exp2_model_comp <- data.frame()
for(id in unique(dat_exp2$human_id)) {
tdat <- subset(dat_exp2,human_id == id)
tot_score <- sum(tdat$score)
tot_time <- sum(tdat$human_rt)
early_dat <- subset(tdat,between(tdat$round,2,6) & (game =="fwg"))
#early_dat <- subset(tdat,between(tdat$round,2,6) & (game =="fwg" | game =="numbers") )
tr_score <- sum(early_dat$score)
id_results <- subset(exp2_results, ID == id)
min_BIC <- apply(id_results[,c("Random_BIC","Bayes_Tr_BIC","Bayes_No_Tr_BIC","QL_states_BIC","EWA_self_BIC","MBM2_BIC")],1,min)
best_model <- c("random","Bayes Tr","Bayes NT", "QL_states","S_EWA", "MBM")[apply(id_results[,c("Random_BIC","Bayes_Tr_BIC","Bayes_No_Tr_BIC","QL_states_BIC","EWA_self_BIC","MBM2_BIC")],1,which.min)]
#
exp2_model_comp <- rbind(exp2_model_comp ,
data.frame(
"human_id" = id,
"condition" = dat_exp2[dat_exp2$human_id==id,"condition"][1],
"Early_game_score" = tr_score,
"Total_score" = tot_score,
"Best_model" = best_model,
"Total_time" = sum(tdat$human_rt),
"TR_minus_NT_BIC" = id_results[,"Bayes_Tr_BIC"] - id_results[,"Bayes_No_Tr_BIC"],
"Rand_minus_best_BIC" =  id_results[,"Random_BIC"] - min_BIC
))
}
write.csv(exp2_model_comp,file="exp2_model_comp.csv",row.names = FALSE)
cor.test(exp2_model_comp$TR_minus_NT_BIC, exp2_model_comp$Early_game_score, method="spearman")
cor.test(exp2_model_comp$Rand_minus_best_BIC, exp2_model_comp$Early_game_score, method="spearman")
barplot(table(exp2_model_comp$Best_model))
# ggboxplot(exp2_model_comp, x = "model", y = "Total_score",
#           color = "model", palette = c("#00AFBB", "#E7B800", "#FC4E07"),
#           order = c("Random", "No Transfer", "Transfer"),
#           ylab = "Total Score", xlab = "Model with best fit")
exp2_model_comp$model <- recode(exp2_model_comp$Best_model,"Bayes Tr" = "Tranfer","Bayes NT" = "No Transfer", "QL_states" = "Q_Learning",  .default = "Random")
model <- factor(exp2_model_comp$model)
condition <- factor(exp2_model_comp$condition)
# Total score by best predictive model
tapply(exp2_model_comp$Total_score, model, mean)
# Compute the analysis of variance
res.aov <- aov(Total_score ~ model + condition, data = exp2_model_comp)
# Summary of the analysis
summary(res.aov)
TukeyHSD(res.aov)
install.packages("citr")
#library("papaja")
require(knitr)
require(citr)
# using some functions dplyr, ggpubr, PairedData and sjPlot. Need to be loaded.
library(tidyr)
library(dplyr)
library(MASS)
library(ggpubr)
library(PairedData)
library(multcompView)
#Experiment 1 raw data
dat <- read.csv("data20180719.csv")
#Experiment 1 raw data
dat <- read.csv("data20180719.csv")
#Experiment 1 raw data
dat <- read.csv("./data20180719.csv")
#Experiment 1 raw data
dat <- read.csv("../data20180719.csv")
# transform 'winner' variable in numeric score
dat$score <- recode(dat$winner, human = 1, tie = 0, ai = -1)
# create a new variable 'block' with round 1...25 = block 1 and round 26...50 as block 2
dat$block <- factor(as.numeric(cut(dat$round,2)),labels =c("first half", "second half"))
# create a new variable "game.f" as a factor variable of games
dat$game.f <- factor(dat$game, labels = c("RPS","FWG","NUM"),levels=c("rps","fwg","numbers"))
#Group data by human_id and calculate mean score per block of each game.
dat2 <- dat %>%
group_by(human_id,condition,game,block,game.f) %>%
summarize(block_score = mean(score))
# Group data by game and ID
dat3 <- group_by(dat2, human_id,game.f,game) %>% summarise(game_score = mean(block_score))
# AFEX PACKAGE FOR RUNNING RM ANOVA AND POST HOC TESTS ############################
citation(package = "afex", lib.loc = NULL, auto = NULL)
library(afex)
a1 <- aov_car( block_score ~ game.f*block*condition + Error(human_id/(game.f*block)), dat2)
summary(a1)
(a1_nice <- nice(a1, es = attr(a1$anova_table, "es"),
observed = attr(a1$anova_table, "observed"),
correction = attr(a1$anova_table, "correction"), MSE = NULL,
intercept = NULL, p_adjust_method = attr(a1$anova_table,
"p_adjust_method"), sig_symbols = attr(a1$anova_table, "sig_symbols")))
write.table(a1_nice,file = "a1.txt", sep = ",", quote = FALSE, row.names = F)
# AFEX PACKAGE FOR RUNNING RM ANOVA AND POST HOC TESTS ############################
citation(package = "afex", lib.loc = NULL, auto = NULL)
library(afex)
a1 <- aov_car( block_score ~ game.f*block*condition + Error(human_id/(game.f*block)), dat2)
summary(a1)
(a1_nice <- nice(a1, es = attr(a1$anova_table, "es"),
observed = attr(a1$anova_table, "observed"),
correction = attr(a1$anova_table, "correction"), MSE = NULL,
intercept = NULL, p_adjust_method = attr(a1$anova_table,
"p_adjust_method"), sig_symbols = attr(a1$anova_table, "sig_symbols")))
write.table(a1_nice,file = "a1.txt", sep = ",", quote = FALSE, row.names = F)
#Pair waise comparison and post hoc tests for the interaction: Game * Block using lsmeans
# game score differences statistically significant?
(ls0 <- lsmeans(a1, "game.f"))
#library("papaja")
require(knitr)
require(citr)
# using some functions dplyr, ggpubr, PairedData and sjPlot. Need to be loaded.
library(tidyr)
library(dplyr)
library(MASS)
library(ggpubr)
library(PairedData)
library(multcompView)
library(knitr)
knitr::opts_chunk$set(echo = TRUE)
#Pair waise comparison and post hoc tests for the interaction: Game * Block using lsmeans
# game score differences statistically significant?
(ls0 <- lsmeans(a1, "game.f"))
# using some functions dplyr, ggpubr, PairedData and sjPlot. Need to be loaded.
library(tidyr)
library(dplyr)
library(MASS)
library(ggpubr)
library(PairedData)
library(multcompView)
# transform 'winner' variable in numeric score
dat$score <- recode(dat$winner, human = 1, tie = 0, ai = -1)
# create a new variable 'block' with round 1...25 = block 1 and round 26...50 as block 2
dat$block <- factor(as.numeric(cut(dat$round,2)),labels =c("first half", "second half"))
# create a new variable "game.f" as a factor variable of games
dat$game.f <- factor(dat$game, labels = c("RPS","FWG","NUM"),levels=c("rps","fwg","numbers"))
# overall score to pay bonuses
dat_score <- dat %>%
group_by(human_id) %>%
summarize(overall_score = sum(score))
(avg_bonus <- floor(mean(abs(dat_score$overall_score))))*0.02
#Group data by human_id and calculate mean score per block of each game.
dat2 <- dat %>%
group_by(human_id,condition,game,block,game.f) %>%
summarize(block_score = mean(score))
# Group data by game and ID
dat3 <- group_by(dat2, human_id,game.f,game) %>% summarise(game_score = mean(block_score))
# head(dat3,6)
# Subsetting scores data by game
rps <- subset(dat3,  game.f == "RPS",game_score)
fwg <- subset(dat3,  game.f == "FWG",game_score)
num <- subset(dat3,  game.f == "NUM",game_score)
# head(rps,6)
# Look at some summary statistics of group means #############################
group_by(dat2, game.f) %>%
summarise(
mean = mean(block_score, na.rm = TRUE),
sd = sd(block_score, na.rm = TRUE)
)
group_by(dat2, game.f, block) %>%
summarise(
count = n(),
mean = mean(block_score, na.rm = TRUE),
sd = sd(block_score, na.rm = TRUE)
)
group_by(dat2, game.f, condition,block) %>%
summarise(
count = n(),
mean = mean(block_score, na.rm = TRUE),
sd = sd(block_score, na.rm = TRUE)
)
# PLOTS  #############################
# Plot scores per game
ggboxplot(dat3, x = "game.f", y = "game_score", group = 1, add =c("mean_ci","jitter"), color="game.f", palette = c("#00AFBB", "#E7B800", "#FC4E07"), order = c("RPS", "FWG","NUM"), ylab = "Score", xlab = "Games")
ggerrorplot(dat3, x = "game.f", y = "game_score", group = 1, color="game.f", desc_stat = "mean_ci",palette = c("#00AFBB", "#E7B800", "#FC4E07"), order = c("RPS", "FWG","NUM"), ylab = "Score", xlab = "Games")
# Plot paired scores between games
#pd <- paired(rps,fwg)
#pd2 <- paired(fwg,num)
#head(pd)
#plot(pd, type = "profile")
#plot(pd2, type = "profile")
ggpaired(dat3, x = "game.f", y = "game_score",color = "game.f", id = "human_id", line.color = "gray", line.size = 0.4, palette = "npg")
# Plot results by game and block (for all 3 games, learning is happening)
ggboxplot(dat2, x = "game", y = "block_score", palette = c("#00AFBB", "#E7B800"),order = c("rps", "fwg","numbers"), fill="block",ylab = "Percentage score", xlab = "Games")
# Group data by game and ID
dat4 <- group_by(dat2, human_id,condition,game.f) %>% summarise(game_score = mean(block_score))
# Level 2 is harder to win against than level 1
ggboxplot(dat2, x = "condition", y = "block_score", palette = c("#00AFBB", "#E7B800"), fill="condition",ylab = "Percentage score", xlab = "Conditions")
ggerrorplot(dat2, x = "condition", y = "block_score", desc_stat = "mean_ci" , palette = c("#00AFBB", "#E7B800"), color="condition",ylab = "Percentage score", xlab = "Conditions")
# Main effect of block
ggerrorplot(dat2, x = "block", y = "block_score", desc_stat = "mean_ci" , palette = c("#00AFBB", "#E7B800"), color="block",ylab = "Percentage score", xlab = "Block")
# Breaking it down by game (seems to be true for RPS and FWG, less so for Numbers )
ggboxplot(dat4, x = "game.f", y = "game_score", palette = c("#00AFBB","#E7B800","#FC4E07"), fill="condition",order = c("RPS", "FWG","NUM"),ylab = "Game Score", xlab = "Conditions")
# AFEX PACKAGE FOR RUNNING RM ANOVA AND POST HOC TESTS ############################
citation(package = "afex", lib.loc = NULL, auto = NULL)
library(afex)
a1 <- aov_car( block_score ~ game.f*block*condition + Error(human_id/(game.f*block)), dat2)
summary(a1)
(a1_nice <- nice(a1, es = attr(a1$anova_table, "es"),
observed = attr(a1$anova_table, "observed"),
correction = attr(a1$anova_table, "correction"), MSE = NULL,
intercept = NULL, p_adjust_method = attr(a1$anova_table,
"p_adjust_method"), sig_symbols = attr(a1$anova_table, "sig_symbols")))
write.table(a1_nice,file = "a1.txt", sep = ",", quote = FALSE, row.names = F)
## Note to Self: no need to worry abour the HF warning. You don't have pb with sphericity according to Mauchly tests, and the warning only applies to Huynh-Feldt corrections for violations of sphericity.
#Pair waise comparison and post hoc tests for the interaction: Game * Block using lsmeans
# game score differences statistically significant?
(ls0 <- lsmeans(a1, "game.f"))
# using some functions dplyr, ggpubr, PairedData and sjPlot. Need to be loaded.
library(tidyr)
library(dplyr)
library(MASS)
library(ggpubr)
library(PairedData)
library(multcompView)
library(lsmeans)
# transform 'winner' variable in numeric score
dat$score <- recode(dat$winner, human = 1, tie = 0, ai = -1)
# create a new variable 'block' with round 1...25 = block 1 and round 26...50 as block 2
dat$block <- factor(as.numeric(cut(dat$round,2)),labels =c("first half", "second half"))
# create a new variable "game.f" as a factor variable of games
dat$game.f <- factor(dat$game, labels = c("RPS","FWG","NUM"),levels=c("rps","fwg","numbers"))
# overall score to pay bonuses
dat_score <- dat %>%
group_by(human_id) %>%
summarize(overall_score = sum(score))
(avg_bonus <- floor(mean(abs(dat_score$overall_score))))*0.02
#Group data by human_id and calculate mean score per block of each game.
dat2 <- dat %>%
group_by(human_id,condition,game,block,game.f) %>%
summarize(block_score = mean(score))
# Group data by game and ID
dat3 <- group_by(dat2, human_id,game.f,game) %>% summarise(game_score = mean(block_score))
# head(dat3,6)
# Subsetting scores data by game
rps <- subset(dat3,  game.f == "RPS",game_score)
fwg <- subset(dat3,  game.f == "FWG",game_score)
num <- subset(dat3,  game.f == "NUM",game_score)
# head(rps,6)
#Pair waise comparison and post hoc tests for the interaction: Game * Block using lsmeans
# game score differences statistically significant?
(ls0 <- lsmeans(a1, "game.f"))
(lsm0 <- update(pairs(ls0, reverse = TRUE), by=NULL, adjust = "holm"))
# Main effect of block
(ls01 <- lsmeans(a1, "block"))
(lsm01 <- update(pairs(ls01, reverse = TRUE), by=NULL, adjust = "holm"))
lsmip(a1, ~block)
# Main effect of condition
(ls02 <- lsmeans(a1, "condition"))
(lsm02 <- update(pairs(ls02, reverse = TRUE), by=NULL, adjust = "holm"))
# Pairwise comparison of first halves by game ( first half RPS vs first half WFG scores....)
(ls1 <- lsmeans(a1, "game.f", by="block"))
(lsm1 <- update(pairs(ls1, reverse = TRUE), by=NULL, adjust = "holm"))
plot(lsm1,by="block")
lsmip(a1, game.f ~ block)
# Pairwise comparison of each game score by block (first half RPS vs second half RPS....) + Control for family wise error:
ls2 <- lsmeans(a1, c("block","game.f"))
(lsm2 <- update(pairs(ls2, reverse = TRUE), by=NULL, adjust = "holm"))
(contr2 <- contrast(ls2, list(G1H2vG2H1 = c(0,1,-1,0,0,0))))
(contr3 <- contrast(ls2, list(G1H1vs0 = c(1,0,0,0,0,0))))
lsmip(a1, block ~ game.f)
lsmip(a1, ~ block * game.f)
# Pairwise comparison of scores facing the two types of players by game:
lsc <- lsmeans(a1, "condition", by="game.f")
(lsmc <- update(pairs(lsc), by=NULL, adjust = "holm"))
plot(lsmc,by="game.f")
lsmip(a1, condition ~ game.f)
#library("papaja")
require(knitr)
require(citr)
# using some functions dplyr, ggpubr, PairedData and sjPlot. Need to be loaded.
library(tidyr)
library(dplyr)
library(MASS)
library(ggpubr)
library(PairedData)
library(multcompView)
library(lsmeans)
#Pair waise comparison and post hoc tests for the interaction: Game * Block using lsmeans
# game score differences statistically significant?
(ls0 <- lsmeans(a1, "game.f"))
(lsm0 <- update(pairs(ls0, reverse = TRUE), by=NULL, adjust = "holm"))
# Main effect of block
(ls01 <- lsmeans(a1, "block"))
(lsm01 <- update(pairs(ls01, reverse = TRUE), by=NULL, adjust = "holm"))
lsmip(a1, ~block)
# Main effect of condition
(ls02 <- lsmeans(a1, "condition"))
(lsm02 <- update(pairs(ls02, reverse = TRUE), by=NULL, adjust = "holm"))
# Pairwise comparison of first halves by game ( first half RPS vs first half WFG scores....)
(ls1 <- lsmeans(a1, "game.f", by="block"))
(lsm1 <- update(pairs(ls1, reverse = TRUE), by=NULL, adjust = "holm"))
plot(lsm1,by="block")
lsmip(a1, game.f ~ block)
# Pairwise comparison of scores facing the two types of players by game:
lsc <- lsmeans(a1, "condition", by="game.f")
(lsmc <- update(pairs(lsc), by=NULL, adjust = "holm"))
plot(lsmc,by="game.f")
lsmip(a1, condition ~ game.f)
#plots
ls4 <- lsmeans(a1, "block",c("condition","game.f"))
ls4
(lsm4 <- update(pairs(ls4, reverse = TRUE), by=NULL, adjust = "holm"))
plot(lsm4,by="game.f")
lsmip(a1, game.f ~ block | condition)
# Interaction plot of game and block by condition
lsmip(a1, game.f ~ block | condition)
lsmip(a1, condition ~ block * game.f)
#Pair waise comparison and post hoc tests for the interaction: Game * Block using lsmeans
# game score differences statistically significant?
(ls0 <- lsmeans(a1, "game.f"))
(lsm0 <- update(pairs(ls0, reverse = TRUE), by=NULL, adjust = "holm"))
# Main effect of block
(ls01 <- lsmeans(a1, "block"))
(lsm01 <- update(pairs(ls01, reverse = TRUE), by=NULL, adjust = "holm"))
lsmip(a1, ~block)
# Main effect of condition
(ls02 <- lsmeans(a1, "condition"))
(lsm02 <- update(pairs(ls02, reverse = TRUE), by=NULL, adjust = "holm"))
# Pairwise comparison of first halves by game ( first half RPS vs first half WFG scores....)
(ls1 <- lsmeans(a1, "game.f", by="block"))
(lsm1 <- update(pairs(ls1, reverse = TRUE), by=NULL, adjust = "holm"))
plot(lsm1,by="block")
lsmip(a1, game.f ~ block)
# Pairwise comparison of scores facing the two types of players by game:
lsc <- lsmeans(a1, "condition", by="game.f")
(lsmc <- update(pairs(lsc), by=NULL, adjust = "holm"))
plot(lsmc,by="game.f")
lsmip(a1, condition ~ game.f)
#plots
ls4 <- lsmeans(a1, "block",c("condition","game.f"))
ls4
(lsm4 <- update(pairs(ls4, reverse = TRUE), by=NULL, adjust = "holm"))
plot(lsm4,by="game.f")
lsmip(a1, game.f ~ block | condition)
# Interaction plot of game and block by condition
lsmip(a1, game.f ~ block | condition)
lsmip(a1, condition ~ block * game.f)
# Pairwise comparison of first halves by game ( first half RPS vs first half WFG scores....)
(ls1 <- lsmeans(a1, "game.f", by="block"))
(lsm1 <- update(pairs(ls1, reverse = TRUE), by=NULL, adjust = "holm"))
plot(lsm1,by="block")
lsmip(a1, game.f ~ block)
# Pairwise comparison of scores facing the two types of players by game:
lsc <- lsmeans(a1, "condition", by="game.f")
(lsmc <- update(pairs(lsc), by=NULL, adjust = "holm"))
plot(lsmc,by="game.f")
lsmip(a1, condition ~ game.f)
#plots
# ls4 <- lsmeans(a1, "block",c("condition","game.f"))
# ls4
# (lsm4 <- update(pairs(ls4, reverse = TRUE), by=NULL, adjust = "holm"))
#
# plot(lsm4,by="game.f")
# lsmip(a1, game.f ~ block | condition)
# Pairwise comparison of first halves by game ( first half RPS vs first half WFG scores....)
(ls1 <- lsmeans(a1, "game.f", by="block"))
(lsm1 <- update(pairs(ls1, reverse = TRUE), by=NULL, adjust = "holm"))
plot(lsm1,by="block")
lsmip(a1, game.f ~ block)
# Pairwise comparison of scores facing the two types of players by game:
# lsc <- lsmeans(a1, "condition", by="game.f")
# (lsmc <- update(pairs(lsc), by=NULL, adjust = "holm"))
# plot(lsmc,by="game.f")
# lsmip(a1, condition ~ game.f)
#plots
# ls4 <- lsmeans(a1, "block",c("condition","game.f"))
# ls4
# (lsm4 <- update(pairs(ls4, reverse = TRUE), by=NULL, adjust = "holm"))
#
# plot(lsm4,by="game.f")
# lsmip(a1, game.f ~ block | condition)
# Pairwise comparison of first halves by game ( first half RPS vs first half WFG scores....)
(ls1 <- lsmeans(a1, "game.f", by="block"))
(lsm1 <- update(pairs(ls1, reverse = TRUE), by=NULL, adjust = "holm"))
lsmip(a1, game.f ~ block)
# Pairwise comparison of scores facing the two types of players by game:
# lsc <- lsmeans(a1, "condition", by="game.f")
# (lsmc <- update(pairs(lsc), by=NULL, adjust = "holm"))
# plot(lsmc,by="game.f")
# lsmip(a1, condition ~ game.f)
#plots
# ls4 <- lsmeans(a1, "block",c("condition","game.f"))
# ls4
# (lsm4 <- update(pairs(ls4, reverse = TRUE), by=NULL, adjust = "holm"))
#
# plot(lsm4,by="game.f")
# lsmip(a1, game.f ~ block | condition)
# Pairwise comparison of scores facing the two types of players by game:
# lsc <- lsmeans(a1, "condition", by="game.f")
# (lsmc <- update(pairs(lsc), by=NULL, adjust = "holm"))
# plot(lsmc,by="game.f")
# lsmip(a1, condition ~ game.f)
#plots
ls4 <- lsmeans(a1, "block",c("condition","game.f"))
ls4
(lsm4 <- update(pairs(ls4, reverse = TRUE), by=NULL, adjust = "holm"))
#
# plot(lsm4,by="game.f")
# lsmip(a1, game.f ~ block | condition)
# Pairwise comparison of first halves by game ( first half RPS vs first half WFG scores....)
(ls1 <- lsmeans(a1, "game.f", by="block"))
(lsm1 <- update(pairs(ls1, reverse = TRUE), by=NULL, adjust = "holm"))
lsmip(a1, game.f ~ block)
(means.int <- lsmeans(a1, specs = c("game.f","block","condition")))
# Transfer level1: compare H1FWG with H1RPS
con1  <- contrast(means.int, list(H1_G2vsH1_G1forlvl1 = c(-1,1,0,0,0,0,0,0,0,0,0,0), H1_G3vsH1_G1forlvl1=c(-1,0,1,0,0,0,0,0,0,0,0,0)))
summary(con1, adjust = "holm")
# Transfer level2: compare H1FWG with H1RPS
con2  <- contrast(means.int, list(H1_G2vsH1_G1forlvl2 = c(0,0,0,0,0,0,-1,1,0,0,0,0), H1_G3vsH1_G1forlvl2=c(0,0,0,0,0,0,-1,0,1,0,0,0)))
summary(con2, adjust = "holm")
#looking at TRIALS 2 to 6 to test robustness of evidence for transfer of learning of opponent strategy #########
dat_26 <- subset(dat,round >1 & round <7, drop =TRUE)
dat2_6 <- dat_26 %>%
group_by(human_id,condition,game.f,confidence,difficulty) %>%
summarise(early_score = mean(score))
# Check group means and SDs
group_by(dat2_6, game.f) %>%
summarise(
count = n(),
mean = mean(early_score, na.rm = TRUE),
sd = sd(early_score, na.rm = TRUE)
)
group_by(dat2_6, game.f,condition) %>%
summarise(
count = n(),
mean = mean(early_score, na.rm = TRUE),
sd = sd(early_score, na.rm = TRUE)
)
# plot scores per game
ggerrorplot(dat2_6, x = "game.f", y = "early_score", group = 1, color="game.f", desc_stat = "mean_ci",palette = c("#00AFBB", "#E7B800", "#FC4E07"), order = c("RPS", "FWG","NUM"), ylab = "Score", xlab = "Games")
View(All_results)
